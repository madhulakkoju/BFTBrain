Index: code/src/com/gbft/plugin/message/DigestMessagePlugin.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.plugin.message;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.List;\n\nimport com.gbft.framework.core.Entity;\nimport com.gbft.framework.data.MessageData;\nimport com.gbft.framework.data.RequestData;\nimport com.gbft.framework.plugins.MessagePlugin;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.gbft.framework.utils.DataUtils;\nimport com.google.protobuf.ByteString;\n\npublic class DigestMessagePlugin implements MessagePlugin {\n\n    private Entity entity;\n\n    public DigestMessagePlugin(Entity entity) {\n        this.entity = entity;\n    }\n\n    @Override\n    public MessageData processIncomingMessage(MessageData message) {\n        if (message.getFlagsList().contains(DataUtils.INVALID)) {\n            return message;\n        }\n\n        var type = message.getMessageType();\n        var hasblock = StateMachine.messages.get(type).hasRequestBlock;\n        if (hasblock) {\n            var computed = getDigest(message.getRequestsList());\n            if (!computed.equals(message.getDigest())) {\n                message = DataUtils.invalidate(message);\n            }\n        }\n\n        return message;\n    }\n\n    @Override\n    public MessageData processOutgoingMessage(MessageData message) {\n        var type = message.getMessageType();\n        var hasblock = StateMachine.messages.get(type).hasRequestBlock;\n        if (hasblock && message.getDigest().isEmpty()) {\n            var computed = getDigest(message.getRequestsList());\n            message = MessageData.newBuilder(message).setDigest(computed).build();\n        }\n\n        return message;\n    }\n\n    private static ByteString getDigest(List<RequestData> requestBlock) {\n        return DataUtils.getDigest(requestBlock);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/plugin/message/DigestMessagePlugin.java b/code/src/com/gbft/plugin/message/DigestMessagePlugin.java
--- a/code/src/com/gbft/plugin/message/DigestMessagePlugin.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/plugin/message/DigestMessagePlugin.java	(date 1713913693842)
@@ -42,10 +42,17 @@
     public MessageData processOutgoingMessage(MessageData message) {
         var type = message.getMessageType();
         var hasblock = StateMachine.messages.get(type).hasRequestBlock;
+//        for(var request:message.getRequestsList()){
+//            entity.l.write(entity.getId(), "\npvalue:"+request.getExeValue());
+//        }
         if (hasblock && message.getDigest().isEmpty()) {
             var computed = getDigest(message.getRequestsList());
             message = MessageData.newBuilder(message).setDigest(computed).build();
         }
+//        entity.l.write(entity.getId(),"\nmessage from process:"+message.toString());
+//        for(var request:message.getRequestsList()){
+//            entity.l.write(entity.getId(), "\npvalue1:"+request.getExeValue());
+//        }
 
         return message;
     }
Index: config/config.framework.yaml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>network:\n  server: 127.0.0.1:9020\n  units:\n    - 127.0.0.1:9021\n    - 127.0.0.1:9022\n    - 127.0.0.1:9023\n    - 127.0.0.1:9024\n    - 127.0.0.1:9025\ngeneral:\n  f: 1\n  max-active-requests: 1000\n  verbosity: v\n  logfile: false # true -> file, false -> stdout\n  learning: true\n  report-sequence: 2500\n  exchange-sequence: 3000\nbenchmark:\n  block-size: 10\n  checkpoint-size: 5000\n  catch-up-k: 2\n  request-interval-micros: 100\n  benchmark-interval-ms: 3000\n  timeout: fixed\n  timeout-trigger-interval-ms: 50\n  client: basic\n  closed-loop:\n    enable: true\n    num-client: 100\n    delay-ms: 0\n  leader-rotate-interval: 100\n  aggregation-delay-ms: 200\nworkload:\n  # lower for more contention\n  contention-level: 100\n  dataset-size: 100\n  payload:\n    request-size: 1000000\n    reply-size: 1000000\n  compute-factor: 0\n  distribution:\n    - 1 # 00\n    - 0 # 04\n    - 0 # 40\n    - 0 # 44\n  read-only-ratio: 0\nfault:\n  in-dark:\n    # the affected entities will always be excluded from leader rotation\n    # set it to be a `non-existing` node (e.g., 100) to avoid this\n    affected-entities:\n      - 1\n    generator:\n      advance: true\n      init: false\n      delay: 10000\n      schedule:\n        values:\n          - false\n          - true\n        intervals:\n          - 10000\n  timeout:\n    affected-entities:\n      - 2\n    generator:\n      advance: true\n      init: 0\n      delay: 10000\n      fixed:\n        value: 0\n  slow-proposal:\n    # affected entities here are the malicious leaders\n    # instead of victims of malicious leaders\n    affected-entities:\n      - 0\n    attacking: true\n    timer: 100\n    \nswitching:\n  protocol-pool:\n    - pbft\n    - zyzzyva\n    - hotstuff\n    - cheapbft\n    - sbft\n    - prime\n  # debug-sequence:\n  #   - cheapbft\n  #   - hotstuff\n  #   - prime\n  #   - zyzzyva\n  #   - pbft\n  #   - sbft\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/config/config.framework.yaml b/config/config.framework.yaml
--- a/config/config.framework.yaml	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/config/config.framework.yaml	(date 1713911066944)
@@ -15,8 +15,8 @@
   report-sequence: 2500
   exchange-sequence: 3000
 benchmark:
-  block-size: 10
-  checkpoint-size: 5000
+  block-size: 5
+  checkpoint-size: 5000 #5000
   catch-up-k: 2
   request-interval-micros: 100
   benchmark-interval-ms: 3000
@@ -31,7 +31,7 @@
   aggregation-delay-ms: 200
 workload:
   # lower for more contention
-  contention-level: 100
+  contention-level: 10
   dataset-size: 100
   payload:
     request-size: 1000000
@@ -75,7 +75,7 @@
       - 0
     attacking: true
     timer: 100
-    
+
 switching:
   protocol-pool:
     - pbft
Index: code/src/com/gbft/framework/core/Node.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.core;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport com.gbft.framework.coordination.CoordinatorUnit;\nimport com.gbft.framework.data.LearningData;\nimport com.gbft.framework.data.MessageData;\nimport com.gbft.framework.fault.PollutionFault;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.gbft.framework.utils.AdvanceConfig;\nimport com.gbft.framework.utils.DataUtils;\nimport com.gbft.framework.utils.FeatureManager;\nimport com.gbft.plugin.message.CheckpointMessagePlugin;\nimport com.gbft.plugin.message.LearningMessagePlugin;\n\npublic class Node extends Entity {\n\n    public Node(int id, CoordinatorUnit coordinator) {\n        super(id, coordinator);\n    }\n\n    @Override\n    protected void execute(long seqnum) {\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n        var requestBlock = checkpoint.getRequestBlock(seqnum);\n\n        if (checkpoint.getReplies(seqnum) == null) {\n            var replies = new HashMap<Long, Integer>();\n            for (var request : requestBlock) {\n                replies.put(request.getRequestNum(), dataset.execute(request));\n            }\n            checkpoint.addReplies(seqnum, replies);\n        }\n\n        // checkpoint\n        if ((seqnum + 1) % checkpointSize == 0) {\n            // copy the current state to checkpoint, new requests can commit but not execute.\n            checkpoint.setServiceState(dataset);\n\n            // update h\n            for (var i = messagePlugins.size() - 1; i >= 0; i--) {\n                var plugin = messagePlugins.get(i);\n                if (plugin instanceof CheckpointMessagePlugin) {\n                    CheckpointMessagePlugin checkpointPlugin = (CheckpointMessagePlugin) plugin;\n                    if (checkpointPlugin.hasQuorum(seqnum / checkpointSize)) {\n                        checkpointManager.setLowWaterMark(seqnum / checkpointSize);\n                    }\n                }\n            }\n\n            // multicast CHECKPOINT message to all other nodes\n            new Thread(() -> checkpointManager.sendCheckpoint(seqnum / checkpointSize)).start();\n        }\n\n        // report local features and reward\n        if (learning) {\n            if (seqnum <= reportSequence) {\n                // request size \n                var request_size = AdvanceConfig.integer(\"workload.payload.request-size\");\n                for (var request : requestBlock) {\n                    featureManager.add(currentEpisodeNum.get(), FeatureManager.REQUEST_SIZE, request_size);\n                    // featureManager.add(currentEpisodeNum.get(), FeatureManager.REQUEST_SIZE, request.getRequestDummy().size());\n                }\n                // fast path frequency\n                featureManager.count(currentEpisodeNum.get(), FeatureManager.FAST_PATH_FREQUENCY);\n                // slow proposal is tracked upon first receiving that message\n            }\n\n            if (seqnum == reportSequence) {\n                // if in dark there will be no report by default\n                var targets = getRolePlugin().getRoleEntities(seqnum, 0, StateMachine.NORMAL_PHASE, StateMachine.NODE);\n                // seqnum represents episode number\n                var message = DataUtils.createMessage((long)currentEpisodeNum.get(), 0L, REPORT, getId(), targets, List.of(), EMPTY_BLOCK,\n                        null, EMPTY_DIGEST);\n                var extractor = featureManager.getExtractor(currentEpisodeNum.get());\n\n                Map<Integer, Float> report = new HashMap<>();\n                if (currentEpisodeNum.get() != 0) {\n                    var prev_checkpoint = checkpointManager.getPrevCheckpointForSeq(seqnum);\n                    if (pollutionFault.getType(this.id) == PollutionFault.POLLUTION_SBFT && prev_checkpoint.getProtocol().equals(\"sbft\")) {\n                        report.put(FeatureManager.REWARD, prev_checkpoint.throughput * 2.5f);\n                    } else if (pollutionFault.getType(this.id) == PollutionFault.POLLUTION_ALL) {\n                        report.put(FeatureManager.REWARD, PollutionFault.randomFeatureGenerator(50000));\n                    } else {\n                        report.put(FeatureManager.REWARD, prev_checkpoint.throughput);\n                    }\n                }\n\n                if (pollutionFault.getType(this.id) == PollutionFault.POLLUTION_ALL) {\n                    report.put(FeatureManager.REQUEST_SIZE, PollutionFault.randomFeatureGenerator(500000f));\n                    report.put(FeatureManager.FAST_PATH_FREQUENCY, PollutionFault.randomFeatureGenerator(1f));\n                    report.put(FeatureManager.SLOWNESS_OF_PROPOSAL, PollutionFault.randomFeatureGenerator(100f));\n                    report.put(FeatureManager.RECEIVED_MESSAGE_PER_SLOT, (float) Math.round(PollutionFault.randomFeatureGenerator(100f)));\n                    report.put(FeatureManager.HAS_FAST_PATH, PollutionFault.randomOnehot());\n                    report.put(FeatureManager.HAS_LEADER_ROTATION, PollutionFault.randomOnehot());\n                } else {\n                    // request\n                    report.put(FeatureManager.REQUEST_SIZE, (float) extractor.average(FeatureManager.REQUEST_SIZE));\n                    // fast path frequency\n                    if (featureManager.hasFastPath.get(checkpoint.getProtocol()) == 0) {\n                        report.put(FeatureManager.FAST_PATH_FREQUENCY, (float) 0.0);\n                    } else {\n                        report.put(FeatureManager.FAST_PATH_FREQUENCY, \n                                1 - (float) extractor.getRatio(FeatureManager.FAST_PATH_FREQUENCY, FeatureManager.SLOW));\n                    }\n                    // slow proposal\n                    report.put(FeatureManager.SLOWNESS_OF_PROPOSAL, extractor.getProposalSlowness());\n                    // number of received messages per slot\n                    report.put(FeatureManager.RECEIVED_MESSAGE_PER_SLOT, (float) extractor.count(FeatureManager.RECEIVED_MESSAGE_PER_SLOT));\n                    // protocol encodings\n                    report.put(FeatureManager.HAS_FAST_PATH, (float) featureManager.hasFastPath.get(checkpoint.getProtocol()));\n                    report.put(FeatureManager.HAS_LEADER_ROTATION, (float) featureManager.hasLeaderRotation.get(checkpoint.getProtocol()));\n                }\n\n                var learningDataBuilder = LearningData.newBuilder().putAllReport(report);\n                message = message.toBuilder().setReport(learningDataBuilder).build();\n\n                sendMessage(message);\n                if (message.getTargetsList().contains(id)) {\n                    // deliver to myself\n                    for (var i = 0; i < messagePlugins.size(); i++) {\n                        var plugin = messagePlugins.get(i);\n                        if (plugin instanceof LearningMessagePlugin) {\n                            final MessageData _message = message;\n                            // new Thread( () -> plugin.processIncomingMessage(_message)).start();\n                            plugin.processIncomingMessage(_message);\n                            break;\n                        }\n                    }\n\n                }\n                System.out.println(\"sending report for episode \" + currentEpisodeNum.get() + \", reportSequence=\" + reportSequence);\n            }\n\n            if (seqnum == exchangeSequence) {\n                Map<Integer, List<Float>> featureToQuorum = new HashMap<>();\n                for (var report : requestBlock.get(0).getReportQuorumList()) {\n                    for (var entry : report.getReportMap().entrySet()) {\n                        featureToQuorum.computeIfAbsent(entry.getKey(), f ->  new ArrayList<>()).add(entry.getValue());\n                    }\n                }\n\n                // take median and send to learning agent\n                Map<Integer, Float> featureToMedian = featureToQuorum.entrySet().stream()\n                        .collect(Collectors.toMap(\n                                entry -> entry.getKey(),\n                                entry -> calculateMedian(entry.getValue())));\n                // reuse the proto field `next_protocol` to store the current protocol just for convenience\n                var learningData = LearningData.newBuilder().putAllReport(featureToMedian).setNextProtocol(checkpoint.getProtocol()).build();\n                new Thread(() -> agentStub.sendData(learningData)).start(); \n                System.out.println(\"notify learning agent for episode \" + currentEpisodeNum.get() + \", exchangeSequence=\" + exchangeSequence);\n            }\n        }\n    }\n\n    @Override\n    public boolean isClient() {\n        return false;\n    }\n\n    private float calculateMedian(List<Float> values) {\n        List<Float> sortedValues = values.stream().sorted().collect(Collectors.toList());\n\n        int size = sortedValues.size();\n        if (size % 2 == 0) {\n            int midIndex = size / 2;\n            return (sortedValues.get(midIndex - 1) + sortedValues.get(midIndex)) / 2.0f;\n        } else {\n            int midIndex = size / 2;\n            return sortedValues.get(midIndex);\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/core/Node.java b/code/src/com/gbft/framework/core/Node.java
--- a/code/src/com/gbft/framework/core/Node.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/core/Node.java	(date 1713894956793)
@@ -9,6 +9,7 @@
 import com.gbft.framework.coordination.CoordinatorUnit;
 import com.gbft.framework.data.LearningData;
 import com.gbft.framework.data.MessageData;
+import com.gbft.framework.data.RequestData;
 import com.gbft.framework.fault.PollutionFault;
 import com.gbft.framework.statemachine.StateMachine;
 import com.gbft.framework.utils.AdvanceConfig;
@@ -16,22 +17,58 @@
 import com.gbft.framework.utils.FeatureManager;
 import com.gbft.plugin.message.CheckpointMessagePlugin;
 import com.gbft.plugin.message.LearningMessagePlugin;
+import com.google.protobuf.Message;
 
 public class Node extends Entity {
-
+    HashMap<String,Integer> exe_values=new HashMap<>(); // string = requestnum
+    HashMap<Long,Boolean> reqexe= new HashMap<>();
+    HashMap<Long, RequestData> msgreq = new HashMap<>();
     public Node(int id, CoordinatorUnit coordinator) {
         super(id, coordinator);
     }
+    public void xov_execute(MessageData message){
+        var type = message.getMessageType();
+        if(type == 0){
+            var request = message.getRequestsList().get(0);
+            long reqnum = request.getRequestNum();
+            msgreq.put(reqnum,request);
+        }
+        else if(type == 13 && !reqexe.getOrDefault(message.getSequenceNum(),false)){
+            reqexe.put(message.getSequenceNum(),true);
+            for(long num : message.getRequestNumsList()){
+                var request = msgreq.get(num);
+                int a = dataset.execute(request);
+                request.setExeValue(a);
+                l.write(id, "\n{\nrequestnum:" + request.getRequestNum() + "\nxov_value:" + request.getExeValue() + "}");
+                exe_values.put(Long.toString(request.getRequestNum()), a);
+            }
+        }
+        else if(type == 12) {
+            reqexe.put(message.getSequenceNum(),true);
+            for (var request : message.getRequestsList()) {
+                int a = dataset.execute(request);
+                request.setExeValue(a);
+                l.write(id, "\n{\nrequestnum:" + request.getRequestNum() + "\nxov_value:" + request.getExeValue() + "}");
+                exe_values.put(Long.toString(request.getRequestNum()), a);
+            }
+        }
+        //exe_values.put(Integer.toString(request.getRecord()), dataset.execute(request));
+    }
 
     @Override
     protected void execute(long seqnum) {
+        l.write(id,"\nnode execute seqnum: "+seqnum);
         var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);
         var requestBlock = checkpoint.getRequestBlock(seqnum);
+        //l.write(id,"\n{\nblock:"+requestBlock.toString()+"\n}");
 
         if (checkpoint.getReplies(seqnum) == null) {
             var replies = new HashMap<Long, Integer>();
             for (var request : requestBlock) {
-                replies.put(request.getRequestNum(), dataset.execute(request));
+                int value = exe_values.get(Long.toString(request.getRequestNum()));
+                replies.put(request.getRequestNum(), request.getExeValue());
+                //replies.put(request.getRequestNum(), dataset.execute(request));
+                l.write(id,"\n{\nrequestnum:"+ request.getRequestNum()+"\nvaluefinal: "+request.getExeValue()+"}");
             }
             checkpoint.addReplies(seqnum, replies);
         }
Index: code/src/com/gbft/framework/core/ClientDataset.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.core;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.concurrent.atomic.LongAdder;\nimport java.util.stream.IntStream;\n\nimport com.gbft.framework.data.RequestData;\nimport com.gbft.framework.data.RequestData.Operation;\nimport com.gbft.framework.utils.AdvanceConfig;\nimport com.gbft.framework.utils.Config;\nimport com.gbft.framework.utils.DataUtils;\n\npublic class ClientDataset extends Dataset {\n\n    private int clientId;\n    private Random random;\n    private Map<Integer, LongAdder> lookahead;\n\n    public ClientDataset(int clientId) {\n        super();\n\n        this.clientId = clientId;\n\n        random = new Random();\n        lookahead = new HashMap<>();\n        IntStream.range(0, RECORD_COUNT)\n                 .forEach(record -> lookahead.computeIfAbsent(record, x -> new LongAdder()).add(DEFAULT_VALUE));\n    }\n\n    @Override\n    public void update(RequestData request, int value) {\n        super.update(request, value);\n\n        var record = request.getRecord();\n        var op = request.getOperation();\n\n        switch (op) {\n        case INC:\n            lookahead.get(record).increment();\n            break;\n        case ADD:\n            lookahead.get(record).add(request.getValue());\n            break;\n        default:\n            break;\n        }\n    }\n\n    public RequestData createRequest(long reqnum) {\n\n        var record = random.nextInt(AdvanceConfig.integer(\"workload.contention-level\"));\n        var operation = Operation.values()[random.nextInt(5)];\n        int value = 0;\n\n        switch (operation) {\n        case ADD:\n            value = random.nextInt(DEFAULT_VALUE);\n            break;\n        case SUB:\n            var max = Math.min(DEFAULT_VALUE, lookahead.get(record).intValue());\n            if (max <= 0) { // < 0 to fix #47\n                operation = Operation.NOP;\n            } else {\n                value = random.nextInt(max);\n                lookahead.get(record).add(-value);\n            }\n            break;\n        case DEC:\n            if (lookahead.get(record).intValue() < 1) {\n                operation = Operation.NOP;\n            } else {\n                lookahead.get(record).decrement();\n            }\n            break;\n        default:\n            break;\n        }\n\n        // generate read only optimization\n        if (Config.stringList(\"plugins.message\").contains(\"read-only\")) {\n            if (random.nextDouble() < AdvanceConfig.doubleNumber(\"workload.read-only-ratio\")) {\n                operation = Operation.READ_ONLY;\n            }\n        }\n\n        return DataUtils.createRequest(reqnum, record, operation, value, clientId);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/core/ClientDataset.java b/code/src/com/gbft/framework/core/ClientDataset.java
--- a/code/src/com/gbft/framework/core/ClientDataset.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/core/ClientDataset.java	(date 1713472970724)
@@ -3,6 +3,7 @@
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Random;
+import java.util.Scanner;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.stream.IntStream;
 
@@ -36,6 +37,9 @@
         var record = request.getRecord();
         var op = request.getOperation();
 
+//        l.write(4,"\n update client dataset: ");
+//        l.write(4,"\n request: {\n "+request+"\n}");
+
         switch (op) {
         case INC:
             lookahead.get(record).increment();
@@ -46,10 +50,22 @@
         default:
             break;
         }
+        l.write(4,"\n request num: "+Long.toString(request.getRequestNum()));
+        //l.write(4,"\n record num: "+Integer.toString(record));
+        //l.write(4,"\n lookahead: "+lookahead.toString());
     }
 
     public RequestData createRequest(long reqnum) {
-
+        Scanner sc= new Scanner(System.in);
+//        System.out.println("waiting for input: ");
+//        int temp =sc.nextInt();
+        long delay = 1 * 10 * 1000;
+        try {
+            Thread.sleep(delay);
+            l.write(4,"\nrequest sent");
+        }catch (InterruptedException e){
+            e.printStackTrace();
+        }
         var record = random.nextInt(AdvanceConfig.integer("workload.contention-level"));
         var operation = Operation.values()[random.nextInt(5)];
         int value = 0;
@@ -86,6 +102,7 @@
         }
 
         return DataUtils.createRequest(reqnum, record, operation, value, clientId);
+
     }
 
 }
Index: code/src/com/gbft/framework/core/Client.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.core;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.LockSupport;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.atomic.AtomicLong;\n\nimport com.gbft.framework.coordination.CoordinatorUnit;\nimport com.gbft.framework.data.RequestData;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.gbft.framework.statemachine.Transition.UpdateMode;\nimport com.gbft.framework.utils.AdvanceConfig;\nimport com.gbft.framework.utils.BenchmarkManager;\nimport com.gbft.framework.utils.Config;\nimport com.gbft.framework.utils.MessageTally.QuorumId;\nimport com.gbft.framework.utils.Printer;\nimport com.gbft.framework.utils.Printer.Verbosity;\n\npublic class Client extends Entity {\n\n    protected long nextRequestNum;\n    protected long intervalns;\n    protected final int requestTargetRole;\n\n    protected ClientDataset dataset;\n\n    private RequestGenerator requestGenerator;\n\n    public Client(int id, CoordinatorUnit coordinator) {\n        super(id, coordinator);\n\n        intervalns = Config.integer(\"benchmark.request-interval-micros\") * 1000L;\n        var targetConfig = Config.string(\"protocol.general.request-target\");\n        requestTargetRole = StateMachine.roles.indexOf(targetConfig);\n\n        dataset = new ClientDataset(id);\n        nextRequestNum = 0L;\n\n        requestGenerator = createRequestGenerator();\n        requestGenerator.init();\n    }\n\n    protected RequestGenerator createRequestGenerator() {\n        if (Config.bool(\"benchmark.closed-loop.enable\")) {\n            return new ClosedLoopRequestGenerator();\n        } else {\n            return new RequestGenerator();\n        }\n    }\n\n    @Override\n    protected boolean checkMessageTally(long seqnum, QuorumId quorumId, UpdateMode updateMode) {\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n\n        var tally = checkpoint.getMessageTally();\n        var viewnum = tally.getMaxQuorum(seqnum, quorumId);\n        if (viewnum != null && viewnum >= currentViewNum) {\n            var block = tally.getQuorumBlock(seqnum, viewnum);\n            if (block != null) {\n                registerBlock(seqnum, block);\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    protected void execute(long seqnum) {\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n\n        var tally = checkpoint.getMessageTally();\n        var viewnum = tally.getMaxQuorum(seqnum);\n        var replies = tally.getQuorumReplies(seqnum, viewnum);\n        currentViewNum = viewnum;\n\n        if (replies != null) {\n            var now = System.nanoTime();\n            for (var entry : replies.entrySet()) {\n                var reqnum = entry.getKey();\n                var request = checkpoint.getRequest(reqnum);\n                dataset.update(request, entry.getValue());\n\n                // benchmarkManager.requestExecuted(reqnum, now);\n            }\n\n            requestGenerator.execute();\n\n        }\n    }\n\n    @Override\n    public Map<String, String> reportBenchmark() {\n        var benchmark = benchmarkManager.getBenchmarkById(reportnum);\n\n        var report = new HashMap<String, String>();\n        var executeMax = benchmark.max(BenchmarkManager.REQUEST_EXECUTE);\n        var executeAvg = benchmark.average(BenchmarkManager.REQUEST_EXECUTE);\n        var executeCount = benchmark.count(BenchmarkManager.REQUEST_EXECUTE);\n        report.put(\"request-execute\",\n                \"avg: \" + Printer.timeFormat(executeAvg, true) + \", max: \" + Printer.timeFormat(executeMax, true) + \", count: \"\n                        + executeCount);\n        report.put(\"request-interval\", Printer.timeFormat(intervalns, true));\n\n        var interval = Config.integer(\"benchmark.benchmark-interval-ms\");\n        var throughput = executeCount / (interval / 1000.0);\n        report.put(\"throughput\", String.format(\"%.2freq/s\", throughput));\n        report.put(\"last-executed-sequence\", \"num: \" + lastExecutedSequenceNum);\n        report.put(\"current-episode\", \"value: \" + currentEpisodeNum.get());\n        report.put(\"current-protocol\", \"value: \" + checkpointManager.getCheckpoint(currentEpisodeNum.get()).getProtocol());\n\n        var blockCount = benchmark.count(BenchmarkManager.BLOCK_EXECUTE);\n        var timeoutCount = benchmark.count(BenchmarkManager.TIMEOUT);\n        report.put(\"slow-path\", String.format(\"ratio: %.2f\",  (double) timeoutCount / (double) blockCount));\n\n        reportnum += 1;\n        return report;\n    }\n\n    @Override\n    public boolean isClient() {\n        return true;\n    }\n\n    public class RequestGenerator {\n\n        public void init() {\n            threads.add(new Thread(new RequestGeneratorRunner()));\n        }\n\n        protected class RequestGeneratorRunner implements Runnable {\n            @Override\n            public void run() {\n\n                while (running) {\n                    var next = System.nanoTime() + intervalns;\n\n                    var request = dataset.createRequest(nextRequestNum);\n                    nextRequestNum += 1;\n\n                    sendRequest(request);\n\n                    while (System.nanoTime() < next) {\n                        LockSupport.parkNanos(intervalns / 3);\n                    }\n                }\n            }\n        }\n\n        protected void sendRequest(RequestData request) {\n            var reqnum = request.getRequestNum();\n            var seqnum = reqnum / blockSize;\n            var view = currentViewNum;\n\n            // wait to know the leader mode if necessary\n            var episode = getEpisodeNum(seqnum);\n            rolePlugin.roleReadLock.lock();\n            try {\n                if (rolePlugin.episodeLeaderMode.get(episode) == null) {\n                    rolePlugin.roleReadLock.unlock();\n                    rolePlugin.roleWriteLock.lock();\n                    try {\n                        while (rolePlugin.episodeLeaderMode.get(episode) == null) {\n                            rolePlugin.roleCondition.await();\n                        }\n                    } catch (InterruptedException e) {\n                        // TODO Auto-generated catch block\n                        e.printStackTrace();\n                    } finally {\n                        rolePlugin.roleWriteLock.unlock();\n                        rolePlugin.roleReadLock.lock();\n                    }\n                }\n            } finally {\n                rolePlugin.roleReadLock.unlock();\n            }\n\n            var targets = rolePlugin.getRoleEntities(seqnum, view, StateMachine.NORMAL_PHASE, requestTargetRole);\n\n            if (request.getOperationValue() == RequestData.Operation.READ_ONLY_VALUE) {\n                targets = rolePlugin.getRoleEntities(seqnum, view, StateMachine.NORMAL_PHASE, StateMachine.NODE);\n            }\n\n            var message = createMessage(null, view, List.of(request), StateMachine.REQUEST, id, targets);\n            sendMessage(message);\n\n            if (Printer.verbosity >= Verbosity.VVV) {\n                Printer.print(Verbosity.VVV, prefix, \"Request created: \", request);\n            }\n        }\n\n        protected void execute() {}\n    }\n\n    public class ClosedLoopRequestGenerator extends RequestGenerator {\n        protected final Semaphore semaphore = new Semaphore(Config.integer(\"benchmark.closed-loop.num-client\"));\n        protected final int block_size = Config.integer(\"benchmark.block-size\");\n\n        protected AtomicLong nextRequestNum = new AtomicLong(0l);\n\n        protected long reqnumcnt = 0l;\n\n        @Override\n        public void init() {\n            for (int i = 0; i < Config.integer(\"benchmark.closed-loop.num-client\"); i ++) {\n                threads.add(new Thread(new ClosedLoopRequestGeneratorRunner()));\n            }\n        }\n        \n        protected class ClosedLoopRequestGeneratorRunner implements Runnable {\n            @Override\n            public void run() {\n                while (running) {\n                    try {\n                        semaphore.acquire();\n\n                        // sleep for `delay` ms\n                        var delay = AdvanceConfig.integer(\"benchmark.closed-loop.delay-ms\");\n                        Thread.sleep(delay);\n\n                        var read_only_buf = 0;\n\n                        for (int i = 0; i < block_size + read_only_buf; i ++) {\n                            var reqnum = nextRequestNum.getAndIncrement();\n                            var request = dataset.createRequest(reqnum);\n\n                            if (request.getOperationValue() == RequestData.Operation.READ_ONLY_VALUE) {\n                                read_only_buf ++;\n                            }\n\n                            // System.out.println(\"client \" + id + \" record \" + (++ reqnumcnt));\n                            // System.out.println(\"client \" + id + \" send request \" + reqnum);\n\n                            sendRequest(request);\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n\n\n        @Override\n        protected void execute() {\n            // System.out.println(\"client \" + id + \" execute\");\n            semaphore.release();\n        }\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/core/Client.java b/code/src/com/gbft/framework/core/Client.java
--- a/code/src/com/gbft/framework/core/Client.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/core/Client.java	(date 1713896724074)
@@ -9,6 +9,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 
 import com.gbft.framework.coordination.CoordinatorUnit;
+import com.gbft.framework.data.MessageData;
 import com.gbft.framework.data.RequestData;
 import com.gbft.framework.statemachine.StateMachine;
 import com.gbft.framework.statemachine.Transition.UpdateMode;
@@ -31,7 +32,7 @@
 
     public Client(int id, CoordinatorUnit coordinator) {
         super(id, coordinator);
-
+        l.write(id,"client called");
         intervalns = Config.integer("benchmark.request-interval-micros") * 1000L;
         var targetConfig = Config.string("protocol.general.request-target");
         requestTargetRole = StateMachine.roles.indexOf(targetConfig);
@@ -43,6 +44,8 @@
         requestGenerator.init();
     }
 
+    public void xov_execute(MessageData message){}
+
     protected RequestGenerator createRequestGenerator() {
         if (Config.bool("benchmark.closed-loop.enable")) {
             return new ClosedLoopRequestGenerator();
@@ -70,8 +73,8 @@
 
     @Override
     protected void execute(long seqnum) {
+        l.write(id,"\nclient class | execute function\n seqnum :"+ Long.toString(seqnum));
         var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);
-
         var tally = checkpoint.getMessageTally();
         var viewnum = tally.getMaxQuorum(seqnum);
         var replies = tally.getQuorumReplies(seqnum, viewnum);
@@ -137,7 +140,7 @@
 
                 while (running) {
                     var next = System.nanoTime() + intervalns;
-
+                    l.write(id,"\nrgr request_num: "+nextRequestNum);
                     var request = dataset.createRequest(nextRequestNum);
                     nextRequestNum += 1;
 
@@ -225,7 +228,11 @@
 
                         for (int i = 0; i < block_size + read_only_buf; i ++) {
                             var reqnum = nextRequestNum.getAndIncrement();
+                            l.write(id,"\nclr request_num: "+reqnum);
                             var request = dataset.createRequest(reqnum);
+//                            int a= dataset.execute(request);
+//                            request.setExeValue(a);
+//                            l.write(id,Integer.toString(request.getExeValue()));
 
                             if (request.getOperationValue() == RequestData.Operation.READ_ONLY_VALUE) {
                                 read_only_buf ++;
Index: code/src/com/gbft/framework/core/Entity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.core;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.stream.Collectors;\n\nimport com.gbft.framework.coordination.CoordinatorUnit;\nimport com.gbft.framework.data.AgentCommGrpc;\nimport com.gbft.framework.data.LearningData;\nimport com.gbft.framework.data.MessageData;\nimport com.gbft.framework.data.RequestData;\nimport com.gbft.framework.data.SwitchingData;\nimport com.gbft.framework.data.AgentCommGrpc.AgentCommBlockingStub;\nimport com.gbft.framework.data.RequestData.Operation;\nimport com.gbft.framework.fault.InDarkFault;\nimport com.gbft.framework.fault.PollutionFault;\nimport com.gbft.framework.fault.SlowProposalFault;\nimport com.gbft.framework.fault.TimeoutFault;\nimport com.gbft.framework.plugins.MessagePlugin;\nimport com.gbft.framework.plugins.PipelinePlugin;\nimport com.gbft.framework.plugins.PluginManager;\nimport com.gbft.framework.plugins.RolePlugin;\nimport com.gbft.framework.plugins.TransitionPlugin;\nimport com.gbft.framework.statemachine.Condition;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.gbft.framework.statemachine.Transition;\nimport com.gbft.framework.statemachine.Transition.UpdateMode;\nimport com.gbft.framework.utils.BenchmarkManager;\nimport com.gbft.framework.utils.CheckpointManager;\nimport com.gbft.framework.utils.Config;\nimport com.gbft.framework.utils.DataUtils;\nimport com.gbft.framework.utils.EntityMapUtils;\nimport com.gbft.framework.utils.FeatureManager;\nimport com.gbft.framework.utils.MessageTally;\nimport com.gbft.framework.utils.MessageTally.QuorumId;\nimport com.gbft.framework.utils.Printer;\nimport com.gbft.framework.utils.Printer.Verbosity;\nimport com.gbft.plugin.role.BasicPrimaryPlugin;\nimport com.gbft.plugin.role.PrimaryPassivePlugin;\nimport com.gbft.framework.utils.Timekeeper;\nimport com.google.protobuf.ByteString;\n\nimport io.grpc.Grpc;\nimport io.grpc.InsecureChannelCredentials;\nimport io.grpc.ManagedChannel;\n\npublic abstract class Entity {\n\n    // Config\n\n    protected final int blockSize; // The number of requests in each block.\n    protected final int checkpointSize; // The number of blocks/sequences in each checkpoint.\n\n    // Properties\n\n    protected final int id;\n    public final String prefix; // The entity prefix when printing messages in output.\n\n    // Protocol Data\n\n    protected ConcurrentLinkedQueue<RequestData> pendingRequests;\n    protected Map<Long, Long> reqnumToSeqnumMap;\n    protected CheckpointManager checkpointManager;\n\n    public final List<RequestData> EMPTY_BLOCK;\n    public final ByteString EMPTY_DIGEST;\n\n    public Dataset dataset;\n\n    // Protocol State\n\n    protected long nextSequence;\n    protected long lastExecutedSequenceNum;\n    protected long currentViewNum;\n    protected Timekeeper timekeeper;\n    protected Map<Long, Transition> executionQueue;\n\n    // Concurrency\n\n    protected Set<Long> updating;\n    protected TreeSet<Long> needsUpdate;\n    protected ReentrantLock stateLock;\n\n    // Plugins\n\n    protected RolePlugin rolePlugin;\n    protected PipelinePlugin pipelinePlugin;\n    protected List<MessagePlugin> messagePlugins;\n    protected List<TransitionPlugin> transitionPlugins;\n\n    // Execution\n\n    protected boolean running;\n    protected List<Thread> threads;\n    protected CoordinatorUnit coordinator;\n\n    // Fault\n\n    protected InDarkFault indarkFault;\n    protected TimeoutFault timeoutFault;\n    protected SlowProposalFault slowProposalFault;\n    protected PollutionFault pollutionFault;\n\n    // Others\n\n    public BenchmarkManager benchmarkManager;\n\n    private Object pendingLock = new Object();\n    private long systemStartTime;\n    private long proposedRequests = 0;\n\n    private double cumulativeDuration = 0.0;\n\n    // Learning\n\n    protected boolean learning;\n    public long reportSequence;\n    public long exchangeSequence;\n    public final int REPORT;\n    public final int REPORT_QUORUM;\n    public final int EPISODE_SIZE;\n    public AtomicInteger currentEpisodeNum;\n    public List<String> protocols;\n\n    // episode -> node -> feature-type -> feature-value\n    protected Map<Integer, Map<Integer, Map<Integer, Float>>> reports;\n    protected MessageTally reportTally;\n\n    protected FeatureManager featureManager;\n    protected EntityCommServer entityCommServer;\n    protected AgentCommBlockingStub agentStub;\n\n    public Entity(int id, CoordinatorUnit coordinator) {\n        this.id = id;\n        this.coordinator = coordinator;\n\n        prefix = \"{\" + id + \"} \";\n\n        blockSize = Config.integer(\"benchmark.block-size\");\n        checkpointSize = Config.integer(\"benchmark.checkpoint-size\");\n\n        learning = Config.bool(\"general.learning\");\n        reportSequence = Config.integer(\"general.report-sequence\");\n        exchangeSequence = Config.integer(\"general.exchange-sequence\");\n        REPORT = StateMachine.messages.indexOf(StateMachine.findMessage(\"report\", \"\"));\n        REPORT_QUORUM = StateMachine.parseQuorum(\"2f + 1\");\n        // episode length = checkpoint length\n        EPISODE_SIZE = Config.integer(\"benchmark.checkpoint-size\");\n        currentEpisodeNum = new AtomicInteger(0);\n        protocols = Config.list(\"switching.debug-sequence\");\n        reports = new ConcurrentHashMap<>();\n        reportTally = new MessageTally();\n\n        currentViewNum = 0L;\n        nextSequence = 0L;\n        lastExecutedSequenceNum = -1L;\n        executionQueue = new HashMap<>();\n\n        pendingRequests = new ConcurrentLinkedQueue<>();\n        reqnumToSeqnumMap = new ConcurrentHashMap<>();\n        checkpointManager = new CheckpointManager(this);\n\n        updating = new HashSet<>();\n        needsUpdate = new TreeSet<>();\n        stateLock = new ReentrantLock();\n\n        dataset = new Dataset();\n\n        threads = new ArrayList<>();\n        timekeeper = new Timekeeper(this);\n        threads.add(new Thread(() -> executor()));\n        threads.add(new Thread(() -> triggerSlowProposal()));\n        threads.add(new Thread(() -> aggStateUpdate()));\n\n        rolePlugin = PluginManager.getRolePlugin(this);\n        pipelinePlugin = PluginManager.getPipelinePlugin(this);\n        messagePlugins = PluginManager.getMessagePlugins(this);\n        transitionPlugins = PluginManager.getTransitionPlugins(this);\n\n        EMPTY_BLOCK = new ArrayList<>();\n        EMPTY_DIGEST = DataUtils.getDigest(EMPTY_BLOCK);\n\n        benchmarkManager = new BenchmarkManager(this);\n        featureManager = new FeatureManager(this);\n        running = true;\n\n        indarkFault = new InDarkFault();\n        timeoutFault = new TimeoutFault();\n        slowProposalFault = new SlowProposalFault();\n        pollutionFault = new PollutionFault();\n\n        checkpointManager.getCheckpoint(0).setProtocol(coordinator.defaultProtocol);\n        checkpointManager.getCheckpoint(0).beginTimestamp = System.nanoTime();\n        rolePlugin.episodeLeaderMode.put(0, Config.string(\"protocol.general.leader\").equals(\"stable\") ? 0 : 1);\n\n        if (!isClient()) {\n            // start the grpc server\n            entityCommServer = new EntityCommServer(this);\n            entityCommServer.start();\n\n            // create the stub for learning agent\n            ManagedChannel channel = Grpc\n                    .newChannelBuilder(\"localhost:\" + entityCommServer.agentPort, InsecureChannelCredentials.create())\n                    .build();\n            agentStub = AgentCommGrpc.newBlockingStub(channel);\n        }\n\n        systemStartTime = System.nanoTime();\n    }\n\n    private long lastSlowProposalTimestamp = 0;\n    private List<RequestData> slowProposalRequests = new ArrayList<>();\n\n    public void addSlowProposal(RequestData request) {\n        synchronized (slowProposalRequests) {\n            slowProposalRequests.add(request);\n            slowProposalRequests.notify();\n        }\n    }\n\n    public void triggerSlowProposal() {\n        while (running) {\n            var duration = slowProposalFault.getPerRequestDelay(this.id);\n\n            synchronized (slowProposalRequests) {\n                // wake up when met the block size\n                while (slowProposalRequests.size() == 0 || \n                        (pendingRequests.size() + slowProposalRequests.size() < blockSize && running)) {\n                    try {\n                        slowProposalRequests.wait();\n                    } catch (InterruptedException e) {\n                    }\n                }\n            }\n\n            // check if delay is enough\n            var now = System.currentTimeMillis();\n            if (now - lastSlowProposalTimestamp < duration) {\n                try {\n                    Thread.sleep(duration - (now - lastSlowProposalTimestamp));\n                } catch (InterruptedException e) {\n                }\n            }\n            lastSlowProposalTimestamp = System.currentTimeMillis();\n\n            synchronized (slowProposalRequests) { \n                synchronized (pendingLock) {\n                    // Fix:\n                    // Notice that slow proposal may be triggered back and forth\n                    // because prime `overwrites` the slow proposal attack\n                    // here see if slowProposalRequests are removed\n                    if (pendingRequests.size() + slowProposalRequests.size() < blockSize) {\n                        continue;\n                    }\n                    var num_req = blockSize - pendingRequests.size();\n                    for (int i = 0; i < num_req; i++) {\n                        pendingRequests.offer(slowProposalRequests.remove(0));\n                    }\n                }\n                // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] packing slow proposal requests, ready for stateUpdate: nextSequence=\" + nextSequence);\n                stateUpdateLoop(nextSequence);\n            }\n        }\n    }\n\n    private TreeSet<Long> aggregationBuffer = new TreeSet<>();\n    private long lastLocalSeq = -1L;\n    public void aggStateUpdate() {\n        var aggregationDelay = Config.integer(\"benchmark.aggregation-delay-ms\");\n        while (running) {\n            try {\n                Thread.sleep(aggregationDelay);\n            } catch (InterruptedException e) {\n            }\n\n            Long seqnum;\n            synchronized (aggregationBuffer) {\n                var newLocalSeq = new TreeSet<Long>();\n                var highers = aggregationBuffer.tailSet(lastLocalSeq, false).iterator();\n\n                // get consecutive seqnum from the aggregation buffer starting from lastLocalSeq+1\n                while (highers.hasNext() && highers.next() == lastLocalSeq + 1) {\n                    newLocalSeq.add(lastLocalSeq + 1);\n                    lastLocalSeq += 1;\n                }\n                if (newLocalSeq.isEmpty()) {\n                    continue;\n                }\n\n                // multiplexing global seqnum with local seqnum\n                seqnum = newLocalSeq.first();\n                var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n                checkpoint.addAggregationValue(seqnum, newLocalSeq);\n                // System.out.println(\"trigger aggStateUpdate seqnum: \" + seqnum + \", newLocalSeq: \" + newLocalSeq.toString());\n\n                aggregationBuffer.clear();\n            }\n            stateUpdate(seqnum);\n\n        }\n    }\n\n    public void handleMessage(MessageData message) {\n\n        if (Printer.verbosity >= Verbosity.VVV) {\n            Printer.print(Verbosity.VVV, prefix, \"Processing \", message);\n        }\n\n        for (var i = messagePlugins.size() - 1; i >= 0; i--) {\n            var plugin = messagePlugins.get(i);\n            message = plugin.processIncomingMessage(message);\n        }\n\n        if (message.getFlagsList().contains(DataUtils.INVALID)) {\n            return;\n        }\n\n        var type = message.getMessageType();\n        if (type == StateMachine.REQUEST) {\n            var request = message.getRequestsList().get(0);\n            var seqnum = getRequestSequence(request.getRequestNum());\n            if (seqnum == null) {\n                // slow proposal\n                if (slowProposalFault.getPerRequestDelay(this.id) > 0) {\n                    // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] add slow proposal: reqnum=\" + request.getRequestNum());\n                    addSlowProposal(request);\n                } else {\n                    // clean up if switch back to fault free\n                    if (slowProposalRequests.size() > 0) {\n                        synchronized (slowProposalRequests) {\n                            while (slowProposalRequests.size() > 0) {\n                                pendingRequests.offer(slowProposalRequests.remove(0));\n                            }\n                        }\n                    }\n                    // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] received request: reqnum=\" + request.getRequestNum());\n                    pendingRequests.offer(request);\n                    stateUpdateLoop(nextSequence);\n                }\n            }\n        } else {\n            Long seqnum = message.getSequenceNum();\n            if (checkpointManager.getCheckpointNum(seqnum) < checkpointManager.getMinCheckpoint()) {\n                return;\n            }\n\n            if (!isValidMessage(message)) {\n                return;\n            }\n\n            var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n            checkpoint.tally(message);\n            checkpoint.addAggregationValue(message);\n            timekeeper.messageReceived(seqnum, currentViewNum, checkpoint.getState(seqnum), message);\n\n            if (Printer.verbosity >= Verbosity.VVV) {\n                Printer.print(Verbosity.VVV, prefix, \"Tally message \", message);\n            }\n\n            stateUpdateLoop(seqnum);\n        }\n\n        var start = DataUtils.toLong(message.getTimestamp());\n        benchmarkManager.messageProcessed(start, System.nanoTime());\n    }\n\n    public void stateUpdateLoop(long seqnum) {\n        Printer.print(Verbosity.VVVV, prefix, \"StateUpdateLoop seqnum: \" + seqnum);\n\n        var result = stateUpdate(seqnum);\n        while (running && result != null && !result.isEmpty()) {\n            var next = result.pollFirst();\n            var more = stateUpdate(next);\n            if (more != null) {\n                result.addAll(more);\n            }\n        }\n    }\n\n    public TreeSet<Long> stateUpdate(long seqnum) {\n        // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] begin stateUpdate: seqnum=\" + seqnum + \n        //             \" (nextSequence=\" + nextSequence + \", lastExecutedSequenceNum=\" + lastExecutedSequenceNum + \")\");\n        \n        benchmarkManager.add(BenchmarkManager.STATE_UPDATE, 0, System.nanoTime());\n\n        // Do not process messages belonging to the next episode\n        if (seqnum > getEndOfEpisode()) {\n            return null;\n        }\n\n        stateLock.lock();\n\n        // TODO: concurrency control for leader rotation protocols\n        if (seqnum <= lastExecutedSequenceNum || isExecuted(seqnum)\n                || (isPrimary(seqnum) && seqnum - lastExecutedSequenceNum > pipelinePlugin.getMaxActiveSequences())) {\n            stateLock.unlock();\n            return null;\n        }\n        benchmarkManager.add(BenchmarkManager.IF1, 0, System.nanoTime());\n\n        if (seqnum > nextSequence) {\n            needsUpdate.add(seqnum);\n            stateLock.unlock();\n            return null;\n        }\n        benchmarkManager.add(BenchmarkManager.IF2, 0, System.nanoTime());\n\n        if (updating.contains(seqnum)) {\n            needsUpdate.add(seqnum);\n            stateLock.unlock();\n            return null;\n        }\n        benchmarkManager.add(BenchmarkManager.IF3, 0, System.nanoTime());\n\n        updating.add(seqnum);\n        stateLock.unlock();\n\n        var stateUpdated = false;\n        var nextseqUpdated = false;\n        var seqExecuted = false;\n\n        int local_cnt = 0;\n        benchmarkManager.add(BenchmarkManager.BEGIN_WHILE_LOOP, 0, System.nanoTime());\n        while (running) {\n            local_cnt++;\n\n            stateUpdated = false;\n\n            var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n            var currentState = checkpoint.getState(seqnum);\n            var phase = StateMachine.states.get(currentState).phase;\n            var roles = rolePlugin.getEntityRoles(seqnum, currentViewNum, phase, id);\n\n            // System.out.println(\"[\" + String.join(\",\", roles.stream().map(x -> x + \"\").toList()) + \"]\");\n\n            // System.out.println(prefix + \"seq_num: \" + seqnum + \"\\t local_cnt: \" + local_cnt + \"\\t current state: \" + StateMachine.states.get(currentState).name);\n\n            searchloop:\n            for (var statenum : List.of(currentState, StateMachine.ANY_STATE)) {\n                if (statenum == -1) {\n                    continue;\n                }\n\n                var state = StateMachine.states.get(statenum);\n                for (var role : roles) {\n                    var candidates = state.transitions.get(role);\n                    if (candidates == null) {\n                        continue;\n                    }\n\n                    for (var transition : candidates) {\n                        var condition = transition.condition;\n                        var conditionType = condition.getType();\n\n                        var conditionMet = false;\n                        if (conditionType == Condition.TRUE_CONDITION) {\n                            conditionMet = true;\n                        } else if (conditionType == Condition.MESSAGE_CONDITION) {\n                            var messageType = condition.getParam(Condition.MESSAGE_TYPE);\n\n                            if (messageType == StateMachine.REQUEST) {                                                 \n                                var block = checkpoint.getRequestBlock(seqnum);\n                                if (block == null || block.isEmpty()) {\n                                    synchronized (pendingLock) {\n                                        if (pendingRequests.size() < blockSize) {\n                                            continue;\n                                        }\n\n                                        // seqnum reserved for feature exchange\n                                        if (learning && seqnum == exchangeSequence && isPrimary(seqnum)) {\n                                            if (!reportTally.hasQuorum(currentEpisodeNum.get(), 0, new QuorumId(REPORT, REPORT_QUORUM))) {\n                                                break searchloop;\n                                            }\n                                        }\n\n                                        block = new ArrayList<RequestData>(blockSize);\n                                        for (var i = 0; i < blockSize; i++) {\n                                            var request = pendingRequests.remove();\n                                            // carry the report quorum in the first request of this reserved block\n                                            if (learning && seqnum == exchangeSequence && isPrimary(seqnum) && i == 0) {\n                                                var reportQuorum = new ArrayList<LearningData>(REPORT_QUORUM);\n                                                reports.get(currentEpisodeNum.get()).entrySet().stream().limit(REPORT_QUORUM).forEach(entry -> {\n                                                    var learningDataBuilder = LearningData.newBuilder().putAllReport(entry.getValue());\n                                                    reportQuorum.add(learningDataBuilder.build());\n                                                });\n                                                request = request.toBuilder().addAllReportQuorum(reportQuorum).build();                                                \n                                            }\n                                            block.add(request);\n                                        }\n                                    }\n                                }\n\n                                var message = createMessage(seqnum, currentViewNum, block, StateMachine.REQUEST, id,\n                                        List.of(id));\n                                checkpoint.tally(message);\n                                benchmarkManager.add(BenchmarkManager.CREATE_REQUEST_BLOCK, 0, System.nanoTime());\n                                \n                                proposedRequests += 1;\n                                // Printer.print(Verbosity.V, prefix, \"Create proposal, seqnum: \" + seqnum);\n                            }\n\n                            var quorumId = new QuorumId(messageType, condition.getParam(Condition.QUORUM));\n                            conditionMet = checkMessageTally(seqnum, quorumId, transition.updateMode);\n                        }\n\n                        if (conditionMet) {\n                            benchmarkManager.add(BenchmarkManager.CONDITION_MET, 0, System.nanoTime());\n\n                            timekeeper.stateUpdated(seqnum, transition.toState);\n\n                            if (StateMachine.isIdle(currentState)) {\n                                benchmarkManager.sequenceStarted(seqnum, System.nanoTime());\n                            }\n\n                            if (transition.updateMode == UpdateMode.AGGREGATION && checkpoint.getAggregationValues(seqnum).isEmpty()) {\n                                // store local seqnum (multiplexing with global seqnum) in the aggregation buffer\n                                synchronized (aggregationBuffer) {\n                                    aggregationBuffer.add(seqnum);\n                                }\n                                break searchloop;\n                            }\n\n                            // track slow path ratio for sbft\n                            if (transition.updateMode == UpdateMode.SLOW) {\n                                featureManager.countPath(currentEpisodeNum.get(), FeatureManager.FAST_PATH_FREQUENCY, FeatureManager.SLOW);    \n                            }\n\n                            transition(seqnum, transition);\n                            stateUpdated = true;\n                            // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] transition state to: seqnum=\" + seqnum + \n                            //                 \", toState=\" + StateMachine.states.get(transition.toState).name);\n\n                            stateLock.lock();\n                            if (nextSequence == seqnum) {\n                                nextSequence += 1;\n                                nextseqUpdated = true;\n                                // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] update nextSequence to: seqnum=\" + seqnum + \n                                //             \", nextSequence=\" + nextSequence);\n                            }\n\n                            if (transition.updateMode == UpdateMode.SEQUENCE) {\n                                seqExecuted = true;\n                                // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] ready for execution: seqnum=\" + seqnum);\n                            }\n                            stateLock.unlock();\n\n                            break searchloop;\n                        }\n                    }\n                }\n            }\n\n            if (!stateUpdated) {\n                var overdue = timekeeper.getOverdue(seqnum);\n                if (overdue != null) {\n                    // System.out.println(prefix + \"seq_num: \" + seqnum + \"\\t overdue, dueLength = \" + overdue.dueLength / 1000.0 + \"us\");\n                    var transition = overdue.transition;\n                    if (transition != null) {\n                        benchmarkManager.start(BenchmarkManager.TIMEOUT, seqnum, 1);\n\n                        transition(seqnum, transition);\n                        timekeeper.stateUpdated(seqnum, transition.toState);\n\n                        stateUpdated = true;\n                    }\n                }\n            }\n\n            if (seqExecuted || !stateUpdated) {\n                break;\n            }\n        }\n\n        stateLock.lock();\n        updating.remove(seqnum);\n        var toUpdate = new TreeSet<Long>();\n        if (nextseqUpdated || needsUpdate.contains(nextSequence)) {\n            toUpdate.add(nextSequence);\n        }\n\n        if (needsUpdate.contains(seqnum)) {\n            needsUpdate.remove(seqnum);\n            toUpdate.add(seqnum);\n        }\n        stateLock.unlock();\n\n        return toUpdate;\n    }\n\n    public Transition processTransition(long seqnum, int state, Transition transition) {\n        for (var i = 0; i < transitionPlugins.size(); i++) {\n            var plugin = transitionPlugins.get(i);\n            transition = plugin.processTransition(seqnum, state, transition);\n            if (transition == null) {\n                break;\n            }\n        }\n\n        return transition;\n    }\n\n    public void executor() {\n        while (running) {\n            Transition transition;\n            synchronized (executionQueue) {\n                while (executionQueue.get(lastExecutedSequenceNum + 1) == null && running) {\n                    try {\n                        executionQueue.wait();\n                    } catch (InterruptedException e) {\n                    }    \n                }\n\n                transition = executionQueue.get(lastExecutedSequenceNum + 1);\n                executionQueue.entrySet().removeIf(entry -> entry.getKey() <= lastExecutedSequenceNum + 1); \n                lastExecutedSequenceNum += 1;\n\n                execute(lastExecutedSequenceNum);\n                // Printer.print(Verbosity.V, prefix, \"[time-since-start=\" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + \"] executed by executor thread: seqnum=\" + lastExecutedSequenceNum);\n            }\n\n            var checkpoint = checkpointManager.getCheckpointForSeq(lastExecutedSequenceNum);\n            var localSeqs = checkpoint.getAggregationValues(lastExecutedSequenceNum);\n\n            // if aggregation then perform execution for all local seq\n            if (!localSeqs.isEmpty() && !isClient()) {\n                // System.out.println(\"begin execution for global order: \" + lastExecutedSequenceNum);\n                for (var localSeq : localSeqs) {\n                    // System.out.println(\"executing localSeq: \" + localSeq);\n                    if (localSeq != lastExecutedSequenceNum) {\n                        // avoid getting null blocks\n                        while (checkpoint.getRequestBlock(localSeq) == null) {\n                            try {\n                                Thread.sleep(1);\n                            } catch (InterruptedException e) {\n                            }\n                        }\n                        execute(localSeq);\n                    }\n\n                    benchmarkManager.sequenceExecuted(localSeq, System.nanoTime());\n                    checkpoint.setState(localSeq, transition.toState);\n\n                    checkSwitching(localSeq);\n                    transition(localSeq, transition);\n                }\n                lastExecutedSequenceNum = localSeqs.pollLast();\n                // System.out.println(\"lastExecutedSequenceNum update to: \" + lastExecutedSequenceNum);\n            } else {\n                benchmarkManager.sequenceExecuted(lastExecutedSequenceNum, System.nanoTime());\n                checkpoint.setState(lastExecutedSequenceNum, transition.toState);\n\n                checkSwitching(lastExecutedSequenceNum);\n                transition(lastExecutedSequenceNum, transition);\n            }\n            // checkSwitching(lastExecutedSequenceNum);\n            stateUpdateLoop(lastExecutedSequenceNum + 1);\n        }\n    }\n\n    private void checkSwitching(long seqnum) {\n        if (protocols.isEmpty() && !learning) {\n            return;\n        }\n\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n\n        // Switch to the next episode\n        if (seqnum == getEndOfEpisode(seqnum)) {\n            var episodeDuration = (System.nanoTime() - checkpoint.beginTimestamp) / 1e9f;\n            cumulativeDuration += (double) episodeDuration;\n            var throughput = benchmarkManager.getBenchmarkByEpisode(currentEpisodeNum.get())\n                    .count(BenchmarkManager.REQUEST_EXECUTE) / episodeDuration;\n\n            var episodeReport = \"[EPISODE REPORT] episode \" + currentEpisodeNum.get() + \": protocol = \" + checkpoint.getProtocol()\n                    + \" , throughput = \" + String.format(\"%.2freq/s\", throughput) + \" , episode time = \" + episodeDuration + \"s, overall time = \" + cumulativeDuration + \"s\";\n            System.out.println(episodeReport);\n            Printer.print(Verbosity.V, prefix, episodeReport);\n            Printer.flush();\n            checkpoint.throughput = throughput;\n\n            String nextProtocol;\n            if (!isClient() && !protocols.isEmpty()) {\n                // static switching in debug mode\n                nextProtocol = protocols.get(currentEpisodeNum.get() % protocols.size());\n            } else {\n                // dynamic switching via learning agent\n                // or client\n                nextProtocol = checkpoint.getDecision();\n            }\n            // warm up episodes\n            if (nextProtocol.equals(\"repeat\")) {\n                nextProtocol = checkpoint.getProtocol();\n            }\n            System.out.println(prefix + \"nextProtocol = \" + nextProtocol); \n            Printer.print(Verbosity.V, prefix, \"nextProtocol = \" + nextProtocol);\n            Printer.flush();\n\n            var checkpointNew = checkpointManager.getCheckpointForSeq(seqnum + 1);\n            checkpointNew.setProtocol(nextProtocol);\n            \n            // Record start of the next episode\n            checkpointNew.beginTimestamp = System.nanoTime();\n\n            // Reload special knobs in protocol.config file\n            slowProposalFault.reloadProtocol(nextProtocol);\n            indarkFault.reloadProtocol(nextProtocol);\n            \n            // Update localSeq for Prime\n            if (nextProtocol.equals(\"prime\")) {\n                synchronized (aggregationBuffer) {\n                    lastLocalSeq = seqnum;\n                }\n            }\n\n            // Update epoch to leader mode mapping\n            Config.setCurrentProtocol(nextProtocol);\n            rolePlugin.roleWriteLock.lock();\n            try {\n                rolePlugin.episodeLeaderMode.put(currentEpisodeNum.get() + 1, \n                        Config.string(\"protocol.general.leader\").equals(\"stable\") ? 0 : 1);\n                System.out.println(\"leader mode set to be \" + Config.string(\"protocol.general.leader\") + \" for the next episode\");\n                Printer.print(Verbosity.V, prefix, \"leader mode set to be \" + Config.string(\"protocol.general.leader\") + \" for the next episode\");\n                Printer.flush();\n                // signal that leader mode for a new episode is available\n                rolePlugin.roleCondition.signalAll();\n            } finally {\n                rolePlugin.roleWriteLock.unlock();\n            }\n        \n            // Update report and exchange sequence\n            reportSequence += EPISODE_SIZE;\n            exchangeSequence += EPISODE_SIZE;\n\n            currentEpisodeNum.incrementAndGet();\n        }\n    }\n\n    public void setServiceState(Map<Integer, Integer> service_state, long lastExecutedSequenceNum) {\n        // lock on execution\n        synchronized (executionQueue) {\n            dataset.setRecords(service_state);\n            \n            stateLock.lock();\n            this.lastExecutedSequenceNum = lastExecutedSequenceNum;\n            this.nextSequence = lastExecutedSequenceNum + 1;\n            stateLock.unlock();\n\n            new Thread(() -> stateUpdateLoop(lastExecutedSequenceNum + 1)).start();\n        }\n    }\n\n    public boolean transition(long seqnum, Transition transition) {\n        benchmarkManager.add(BenchmarkManager.TRANSITION, 0, System.nanoTime());\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n        var currentState = checkpoint.getState(seqnum);\n        var phase = StateMachine.states.get(currentState).phase;\n\n        var requestBlock = checkpoint.getRequestBlock(seqnum);\n\n        // if update mode is sequence mode\n        // **and** current state is not the same as the target state\n        // this shall be the execution transition\n        if (transition.updateMode == UpdateMode.SEQUENCE && currentState != transition.toState) {\n            // special case for proposal slowness measurement on zyzzyva leader \n            if (checkpoint.getProtocol().equals(\"zyzzyva\") && isPrimary(seqnum)) {\n                featureManager.received(getEpisodeNum(seqnum), seqnum);\n            }\n\n            Printer.print(Verbosity.VVV, prefix, \"Execution START: \" + seqnum);\n            // execute(seqnum);\n            synchronized (executionQueue) {\n                executionQueue.put(seqnum, transition);\n                executionQueue.notify();\n            }\n            return false;\n        }\n\n        checkpoint.setState(seqnum, transition.toState);\n        if (transition.updateMode == UpdateMode.VIEW) {\n            pendingRequests.clear();\n            currentViewNum += 1;\n        }\n\n        var messages = new ArrayList<MessageData>();\n\n        for (var pair : transition.responses) {\n            var role = pair.getLeft();\n            var messageType = pair.getRight();\n\n            if (role == StateMachine.CLIENT) {\n                var targets = List.copyOf(requestBlock.stream().map(r -> r.getClient()).collect(Collectors.toSet()));\n                var message = createMessage(seqnum, currentViewNum, null, messageType, id, targets);\n                messages.add(message);\n            } else {\n                var targets = rolePlugin.getRoleEntities(seqnum, currentViewNum, phase, role);\n                var message = createMessage(seqnum, currentViewNum, null, messageType, id, targets);\n                messages.add(message);\n            }\n        }\n\n        for (var pair : transition.extraTally) {\n            var role = pair.getLeft();\n            var messageType = pair.getRight();\n            var entities = rolePlugin.getRoleEntities(seqnum, currentViewNum, phase, role);\n\n            // Message from entities to self\n            // if entities = [primary]\n            // then the message will be [0 -> [0], 0 -> [1], 0 -> [2], 0 -> [3],]\n            for (var entity : entities) {\n                var message = createMessage(seqnum, currentViewNum, null, messageType, entity, List.of(id));\n                checkpoint.tally(message);\n\n                if (Printer.verbosity >= Verbosity.VVV) {\n                    Printer.print(Verbosity.VVV, prefix, \"Processing extra \", message);\n                    Printer.print(Verbosity.VVV, prefix, \"Tally message extra \", message);\n                }\n            }\n        }\n\n        messages.parallelStream().forEach(m -> sendMessage(m));\n        for (var message : messages) {\n            if (message.getTargetsList().contains(id)) {\n                checkpoint.tally(message);\n\n                if (Printer.verbosity >= Verbosity.VVV) {\n                    Printer.print(Verbosity.VVV, prefix, \"Processing self via transition \", message);\n                    Printer.print(Verbosity.VVV, prefix, \"Tally message self via transition \", message);\n                }\n            }\n        }\n\n        var roles = rolePlugin.getEntityRoles(seqnum, currentViewNum, phase, id);\n        for (var statenum : List.of(transition.toState, StateMachine.ANY_STATE)) {\n            if (statenum < 0) {\n                continue;\n            }\n            var state = StateMachine.states.get(statenum);\n            for (var role : roles) {\n                var candidates = state.transitions.get(role);\n                if (candidates == null) {\n                    continue;\n                }\n\n                for (var candidate : candidates) {\n                    var condition = candidate.condition;\n                    if (condition.getType() == Condition.TIMEOUT_CONDITION) {\n                        var mode = condition.getParam(Condition.TIMEOUT_MODE);\n                        var multiplier = condition.getParam(Condition.TIMEOUT_MULTIPLIER);\n                        timekeeper.startTimer(seqnum, currentViewNum, statenum, mode, multiplier, candidate);\n                    }\n                }\n            }\n        }\n\n        if (Printer.verbosity >= Verbosity.VVV) {\n            var prevstr = StateMachine.states.get(currentState).name;\n            var nextstr = StateMachine.states.get(transition.toState).name;\n            var debugstr = new StringBuilder(\"Transition \").append(seqnum).append(\" from \")\n                                                           .append(prevstr).append(\" to \")\n                                                           .append(nextstr).toString();\n            Printer.print(Verbosity.VVV, prefix, debugstr);\n        }\n\n        for (var i = 0; i < transitionPlugins.size(); i++) {\n            var plugin = transitionPlugins.get(i);\n            plugin.postTransition(seqnum, currentState, transition);\n        }\n\n        return true;\n    }\n\n    public boolean isPrimary() {\n        var is_primary = false;\n        if (rolePlugin instanceof BasicPrimaryPlugin) {\n            // judge whether is primary in the first epoch (this is only used for generating leader attack)\n            if (rolePlugin.getEntityRoles(0, currentViewNum, 0, this.id).contains(StateMachine.roles.indexOf(\"primary\"))) {\n                is_primary = true;\n            }\n        } else if (rolePlugin instanceof PrimaryPassivePlugin) {\n            if (rolePlugin.getEntityRoles(0, currentViewNum, StateMachine.NORMAL_PHASE, this.id).contains(StateMachine.roles.indexOf(\"primary\"))) {\n                is_primary = true;\n            }\n        } else {\n            // TODO: handle other cases\n        }\n        return is_primary;\n    }\n\n    public boolean isPrimary(long seqnum) {\n        var is_primary = false;\n        if (rolePlugin instanceof BasicPrimaryPlugin) {\n            // judge whether is primary\n            if (rolePlugin.getEntityRoles(seqnum, currentViewNum, 0, this.id).contains(StateMachine.roles.indexOf(\"primary\"))) {\n                is_primary = true;\n            }\n        } else if (rolePlugin instanceof PrimaryPassivePlugin) {\n            if (rolePlugin.getEntityRoles(seqnum, currentViewNum, StateMachine.NORMAL_PHASE, this.id).contains(StateMachine.roles.indexOf(\"primary\"))) {\n                is_primary = true;\n            }\n        } else {\n            // TODO: handle other cases\n        }\n        return is_primary;\n    }\n\n    public void sendMessage(MessageData message) {\n        if (message.getFlagsList().contains(DataUtils.INVALID)) {\n            return;\n        }\n\n        if (Printer.verbosity >= Verbosity.VVV) {\n            Printer.print(Verbosity.VVV, prefix, \"Sending message: \", message);\n        }\n        // Printer.print(Verbosity.V, prefix, \"Sending message: \", message);\n\n        pipelinePlugin.sendMessage(message, this.id);\n    }\n\n    public MessageData createMessage(Long seqnum, long viewNum, List<RequestData> block, int type, int source,\n            List<Integer> targets) {\n\n        ByteString digest = null;\n        Map<Long, Integer> replies = null;\n        MessageData message;\n        Set<Long> aggregationValues = null;\n\n        if (seqnum != null) {\n            var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n\n            if (block == null) {\n                block = checkpoint.getRequestBlock(seqnum);\n            }\n\n            digest = checkpoint.getMessageTally().getQuorumDigest(seqnum, viewNum);\n            if (digest == null) {\n                digest = DataUtils.getDigest(block);\n            }\n\n            if (type == StateMachine.REPLY) {\n                replies = checkpoint.getReplies(seqnum);\n            }\n\n            if (!checkpoint.getAggregationValues(seqnum).isEmpty()) {\n                aggregationValues = checkpoint.getAggregationValues(seqnum);\n            }\n        }\n\n        var hasblock = StateMachine.messages.get(type).hasRequestBlock;\n        if (hasblock) {\n            message = DataUtils.createMessage(seqnum, viewNum, type, source, targets, null, block, replies, digest);\n        } else {\n            var reqnums = block.stream().map(req -> req.getRequestNum()).toList();\n            message = DataUtils.createMessage(seqnum, viewNum, type, source, targets, reqnums, null, replies, digest);\n        }\n\n        // carry aggregation values if exist\n        if (aggregationValues != null) {\n            message = message.toBuilder().addAllAggregationValues(aggregationValues).build();\n        }\n\n        // notify client about the next protocol inside REPLY message\n        if (seqnum != null && seqnum == getEndOfEpisode(seqnum) && type == StateMachine.REPLY) {\n            var checkpointNew = checkpointManager.getCheckpointForSeq(seqnum + 1);\n            var protocol = checkpointNew.getProtocol();\n\n            var switchingDataBuilder = SwitchingData.newBuilder().setNextProtocol(protocol);\n            message = message.toBuilder().setSwitch(switchingDataBuilder).build();        \n            // System.out.println(\"createMessage: attach nextProtocol = \" + protocol + \" to REPLY message\");  \n        }\n\n        return processMessage(message);\n    }\n\n    public MessageData processMessage(MessageData message) {\n        for (var i = 0; i < messagePlugins.size(); i++) {\n            var plugin = messagePlugins.get(i);\n            message = plugin.processOutgoingMessage(message);\n        }\n\n        return message;\n    }\n\n    protected boolean checkMessageTally(long seqnum, QuorumId quorumId, UpdateMode updateMode) {\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n        var tally = checkpoint.getMessageTally();\n        var checkview = updateMode == UpdateMode.VIEW ? currentViewNum + 1 : currentViewNum;\n        //var quorumId = new QuorumId(condition.getParam(Condition.MESSAGE_TYPE), condition.getParam(Condition.QUORUM));\n        var viewnum = tally.getMaxQuorum(seqnum, quorumId);\n        if (viewnum != null && viewnum == checkview) {\n            var block = tally.getQuorumBlock(seqnum, viewnum);\n            if (block != null) {\n                registerBlock(seqnum, block);\n            }\n\n            if (Printer.verbosity >= Verbosity.VVVVV) {\n                Printer.print(Verbosity.VVVVV, \"Checking Message Tally Success: \", StateMachine.messages.get(quorumId.message).name.toUpperCase() + \" seqnum: \" + seqnum + \" size: \" + quorumId.quorum);\n            }\n            return true;\n        }\n\n        if (Printer.verbosity >= Verbosity.VVVVV) {\n            Printer.print(Verbosity.VVVVV, \"Checking Message Tally Failed: \", StateMachine.messages.get(quorumId.message).name.toUpperCase() + \" seqnum: \" + seqnum + \" size: \" + quorumId.quorum);\n        }\n\n        return false;\n    }\n\n    public boolean isValidMessage(MessageData message) {\n        // var type = message.getMessageType();\n        // var messagePhases = StateMachine.messages.get(type).phases;\n\n        // var seqnum = message.getSequenceNum();\n        // var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n        // var statenum = checkpoint.getState(seqnum);\n        // var currentPhase = StateMachine.states.get(statenum).phase;\n\n        // return currentPhase == StateMachine.NORMAL_PHASE || messagePhases.contains(currentPhase);\n        return true;\n    }\n\n    protected boolean isExecuted(long seqnum) {\n        return checkpointManager.getCheckpointForSeq(seqnum).getState(seqnum) == StateMachine.EXECUTED;\n    }\n\n    protected void registerBlock(long seqnum, List<RequestData> block) {\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n        if (checkpoint.getRequestBlock(seqnum) == null) {\n            for (var request : block) {\n                reqnumToSeqnumMap.put(request.getRequestNum(), seqnum);\n            }\n\n            checkpoint.addRequestBlock(seqnum, block);\n            //// benchmarkManager.sequenceStarted(seqnum, DataUtils.timeus());\n        }\n    }\n\n    public Long getRequestSequence(long reqnum) {\n        return reqnumToSeqnumMap.get(reqnum);\n    }\n\n    public void start() {\n        benchmarkManager.start();\n        // TODO: Use Virtual Threads\n        threads.forEach(thread -> thread.start());\n    }\n\n    public void stop() {\n        running = false;\n        threads.forEach(thread -> thread.interrupt());\n    }\n\n    public void registerThread(Thread thread) {\n        threads.add(thread);\n    }\n\n    protected int reportnum = 0;\n\n    public Map<String, String> reportBenchmark() {\n        var benchmark = benchmarkManager.getBenchmarkById(reportnum);\n\n        var report = new HashMap<String, String>();\n        var queueMax = benchmark.max(BenchmarkManager.REQUEST_QUEUE);\n        var queueAvg = benchmark.average(BenchmarkManager.REQUEST_QUEUE);\n        report.put(\"request-queue\",\n                \"avg: \" + Printer.timeFormat(queueAvg, true) + \", max: \" + Printer.timeFormat(queueMax, true));\n\n        var messageMax = benchmark.max(BenchmarkManager.MESSAGE_PROCESS);\n        var messageAvg = benchmark.average(BenchmarkManager.MESSAGE_PROCESS);\n        var messageCount = benchmark.count(BenchmarkManager.MESSAGE_PROCESS);\n        report.put(\"message-process\",\n                \"avg: \" + Printer.timeFormat(messageAvg, true) + \", max: \" + Printer.timeFormat(messageMax, true) + \", count: \"\n                        + messageCount);\n\n        var blockMax = benchmark.max(BenchmarkManager.BLOCK_EXECUTE);\n        var blockAvg = benchmark.average(BenchmarkManager.BLOCK_EXECUTE);\n        var blockCount = benchmark.count(BenchmarkManager.BLOCK_EXECUTE);\n        report.put(\"block-execute\",\n                \"avg: \" + Printer.timeFormat(blockAvg, true) + \", max: \" + Printer.timeFormat(blockMax, true) + \", count: \"\n                        + blockCount);\n\n        // report.put(\"state-update\", \"count: \" + benchmark.count(BenchmarkManager.STATE_UPDATE));\n        // report.put(\"state-update-if1\", \"count: \" + benchmark.count(BenchmarkManager.IF1));\n        // report.put(\"state-update-if2\", \"count: \" + benchmark.count(BenchmarkManager.IF2));\n        // report.put(\"state-update-if3\", \"count: \" + benchmark.count(BenchmarkManager.IF3));\n        // report.put(\"begin-while-loop\", \"count: \" + benchmark.count(BenchmarkManager.BEGIN_WHILE_LOOP));\n        // report.put(\"create-request-block\", \"count: \" + benchmark.count(BenchmarkManager.CREATE_REQUEST_BLOCK));\n        // report.put(\"condition-met\", \"count: \" + benchmark.count(BenchmarkManager.CONDITION_MET));\n        // report.put(\"transition\", \"count: \" + benchmark.count(BenchmarkManager.TRANSITION));\n        report.put(\"last-executed-sequence\", \"num: \" + lastExecutedSequenceNum);\n        report.put(\"in-dark\", \"value: \" + indarkFault.getApply());\n\n        var timeoutCount = benchmark.count(BenchmarkManager.TIMEOUT);\n        report.put(\"slow-path\", String.format(\"ratio: %.2f\",  (double) timeoutCount / (double) blockCount));\n        report.put(\"proposal (since-start)\", \"count: \" + proposedRequests);\n\n        report.put(\"current-episode\", \"value: \" + currentEpisodeNum.get());\n        report.put(\"current-protocol\", \"value: \" + checkpointManager.getCheckpoint(currentEpisodeNum.get()).getProtocol());\n\n        reportnum += 1;\n        return report;\n    }\n\n    // Abstract Methods\n\n    protected abstract void execute(long seqnum);\n\n    public abstract boolean isClient();\n\n    // Getters\n\n    public int getId() {\n        return id;\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    public long getLastExecutedSequenceNum() {\n        return lastExecutedSequenceNum;\n    }\n\n    public long getNextSequence() {\n        return nextSequence;\n    }\n\n    public long getCurrentViewNum() {\n        return currentViewNum;\n    }\n\n    public Timekeeper getTimekeeper() {\n        return timekeeper;\n    }\n\n    public CoordinatorUnit getCoordinator() {\n        return coordinator;\n    }\n\n    public CheckpointManager getCheckpointManager() {\n        return checkpointManager;\n    }\n\n    public RolePlugin getRolePlugin() {\n        return rolePlugin;\n    }\n\n    public List<MessagePlugin> getMessagePlugins() {\n        return messagePlugins;\n    }\n\n    public List<TransitionPlugin> getTransitionPlugins() {\n        return transitionPlugins;\n    }\n\n    public InDarkFault getInDarkFault() {\n        return indarkFault;\n    }\n\n    public TimeoutFault getTimeoutFault() {\n        return timeoutFault;\n    }\n\n    public SlowProposalFault getSlowProposalFault() {\n        return slowProposalFault;\n    }\n\n    public PollutionFault getPollutionFault() {\n        return pollutionFault;\n    }\n\n    public Map<Integer, Map<Integer, Map<Integer, Float>>> getReports() {\n        return reports;\n    }\n\n    public MessageTally getReportTally() {\n        return reportTally;\n    }\n\n    public FeatureManager getFeatureManager() {\n        return featureManager;\n    }\n\n    public long getEndOfEpisode() {\n        return (currentEpisodeNum.get() + 1) * EPISODE_SIZE - 1;\n    }\n    \n    public long getEndOfEpisode(long seqnum) {\n        return (getEpisodeNum(seqnum) + 1) * EPISODE_SIZE - 1;\n    }\n\n    public long getBeginOfEpisode(long seqnum) {\n        return getEpisodeNum(seqnum) * EPISODE_SIZE;\n    }\n\n    public int getEpisodeNum(long seqnum) {\n        return (int) (seqnum / EPISODE_SIZE);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/core/Entity.java b/code/src/com/gbft/framework/core/Entity.java
--- a/code/src/com/gbft/framework/core/Entity.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/core/Entity.java	(date 1713913876562)
@@ -50,10 +50,13 @@
 import com.gbft.framework.utils.Timekeeper;
 import com.google.protobuf.ByteString;
 
+import com.google.protobuf.Message;
 import io.grpc.Grpc;
 import io.grpc.InsecureChannelCredentials;
 import io.grpc.ManagedChannel;
 
+import com.gbft.framework.coordination.LogWrite;
+
 public abstract class Entity {
 
     // Config
@@ -139,11 +142,13 @@
     protected FeatureManager featureManager;
     protected EntityCommServer entityCommServer;
     protected AgentCommBlockingStub agentStub;
+    public LogWrite l =new LogWrite();
 
     public Entity(int id, CoordinatorUnit coordinator) {
         this.id = id;
         this.coordinator = coordinator;
-
+        l.CoreIntialize(id);
+        l.write(id,Integer.toString(id));
         prefix = "{" + id + "} ";
 
         blockSize = Config.integer("benchmark.block-size");
@@ -326,7 +331,14 @@
         }
 
         var type = message.getMessageType();
+        l.write(id,"\nstatetype: "+type+"\nseqnum:"+message.getSequenceNum());
+
+        if(type == 12 || type == 13){
+            xov_execute(message);
+        }
         if (type == StateMachine.REQUEST) {
+            //l.write(id,"seqnum"+message.getSequenceNum());
+            xov_execute(message);
             var request = message.getRequestsList().get(0);
             var seqnum = getRequestSequence(request.getRequestNum());
             if (seqnum == null) {
@@ -378,6 +390,7 @@
         Printer.print(Verbosity.VVVV, prefix, "StateUpdateLoop seqnum: " + seqnum);
 
         var result = stateUpdate(seqnum);
+        //l.write(id,"stateupdate: \n seqnum: "+Long.toString(seqnum) + "\n result: "+ result+" end.... ");
         while (running && result != null && !result.isEmpty()) {
             var next = result.pollFirst();
             var more = stateUpdate(next);
@@ -388,7 +401,7 @@
     }
 
     public TreeSet<Long> stateUpdate(long seqnum) {
-        // Printer.print(Verbosity.V, prefix, "[time-since-start=" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + "] begin stateUpdate: seqnum=" + seqnum + 
+        // Printer.print(Verbosity.V, prefix, "[time-since-start=" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + "] begin stateUpdate: seqnum=" + seqnum +
         //             " (nextSequence=" + nextSequence + ", lastExecutedSequenceNum=" + lastExecutedSequenceNum + ")");
         
         benchmarkManager.add(BenchmarkManager.STATE_UPDATE, 0, System.nanoTime());
@@ -431,6 +444,8 @@
 
         int local_cnt = 0;
         benchmarkManager.add(BenchmarkManager.BEGIN_WHILE_LOOP, 0, System.nanoTime());
+
+
         while (running) {
             local_cnt++;
 
@@ -440,6 +455,8 @@
             var currentState = checkpoint.getState(seqnum);
             var phase = StateMachine.states.get(currentState).phase;
             var roles = rolePlugin.getEntityRoles(seqnum, currentViewNum, phase, id);
+//            l.write(id,"\n currentstate: "+currentState+"\n phase: "+phase+"\n roles: "+roles);
+//            l.write(id,"\nseq num: "+seqnum);
 
             // System.out.println("[" + String.join(",", roles.stream().map(x -> x + "").toList()) + "]");
 
@@ -452,8 +469,10 @@
                 }
 
                 var state = StateMachine.states.get(statenum);
+                //l.write(id,"\n state: "+state);
                 for (var role : roles) {
                     var candidates = state.transitions.get(role);
+                    //l.write(id,"\n candidates: "+candidates);
                     if (candidates == null) {
                         continue;
                     }
@@ -462,6 +481,8 @@
                         var condition = transition.condition;
                         var conditionType = condition.getType();
 
+                       // l.write(id,"\ncondition: "+condition+"\n conditiontype: "+conditionType);
+
                         var conditionMet = false;
                         if (conditionType == Condition.TRUE_CONDITION) {
                             conditionMet = true;
@@ -486,6 +507,7 @@
                                         block = new ArrayList<RequestData>(blockSize);
                                         for (var i = 0; i < blockSize; i++) {
                                             var request = pendingRequests.remove();
+                                            //l.write(id,"\nrequestnum:"+request.getRequestNum()+"  requestvalue:"+request.getExeValue());
                                             // carry the report quorum in the first request of this reserved block
                                             if (learning && seqnum == exchangeSequence && isPrimary(seqnum) && i == 0) {
                                                 var reportQuorum = new ArrayList<LearningData>(REPORT_QUORUM);
@@ -495,14 +517,23 @@
                                                 });
                                                 request = request.toBuilder().addAllReportQuorum(reportQuorum).build();                                                
                                             }
+                                            //l.write(id,"\nrequestnum:"+request.getRequestNum()+"  requestvalue:"+request.getExeValue());
                                             block.add(request);
+//                                            for(var request1:block){
+//                                                l.write(id, "\n{\nblockreq_0:"+request1.toString()+"\nblockvalue_0: "+request1.getExeValue()+"}");
+//                                            }
+
                                         }
                                     }
                                 }
 
                                 var message = createMessage(seqnum, currentViewNum, block, StateMachine.REQUEST, id,
                                         List.of(id));
+                                //l.write(id,"\ncreate message: "+message.toString());
                                 checkpoint.tally(message);
+//                                for(var request1:message.getRequestsList()){
+//                                    l.write(id, "\n{\nblockreq_2:"+request1.toString()+"\nblockvalue_2: "+request1.getExeValue()+"}");
+//                                }
                                 benchmarkManager.add(BenchmarkManager.CREATE_REQUEST_BLOCK, 0, System.nanoTime());
                                 
                                 proposedRequests += 1;
@@ -623,7 +654,7 @@
                 transition = executionQueue.get(lastExecutedSequenceNum + 1);
                 executionQueue.entrySet().removeIf(entry -> entry.getKey() <= lastExecutedSequenceNum + 1); 
                 lastExecutedSequenceNum += 1;
-
+                l.write(id,"\nxecutor seqnum: "+lastExecutedSequenceNum);
                 execute(lastExecutedSequenceNum);
                 // Printer.print(Verbosity.V, prefix, "[time-since-start=" + Printer.timeFormat(System.nanoTime() - systemStartTime, true) + "] executed by executor thread: seqnum=" + lastExecutedSequenceNum);
             }
@@ -956,9 +987,9 @@
         }
 
         var hasblock = StateMachine.messages.get(type).hasRequestBlock;
-        if (hasblock) {
+        if (hasblock) { // creating message for block
             message = DataUtils.createMessage(seqnum, viewNum, type, source, targets, null, block, replies, digest);
-        } else {
+        } else { // creating message for replies
             var reqnums = block.stream().map(req -> req.getRequestNum()).toList();
             message = DataUtils.createMessage(seqnum, viewNum, type, source, targets, reqnums, null, replies, digest);
         }
@@ -982,10 +1013,16 @@
     }
 
     public MessageData processMessage(MessageData message) {
+        var msg= message;
         for (var i = 0; i < messagePlugins.size(); i++) {
             var plugin = messagePlugins.get(i);
             message = plugin.processOutgoingMessage(message);
         }
+        for(int i=0;i<message.getRequestsList().size();i++){
+            message.getRequestsList().get(i).setExeValue(msg.getRequestsList().get(i).getExeValue());
+            int a= message.getRequestsList().get(i).getExeValue();
+            l.write(id, "\n{\nrequestnum:"+message.getRequestsList().get(i).getRequestNum()+"\nblockvalue_5: "+message.getRequestsList().get(i).getExeValue()+"}");
+        }
 
         return message;
     }
@@ -1038,6 +1075,10 @@
             for (var request : block) {
                 reqnumToSeqnumMap.put(request.getRequestNum(), seqnum);
             }
+               // var requests=message.getRequestsList();
+            for(var request:block){
+                l.write(id, "\n{\nrequestnum:"+request.getRequestNum()+"\nregistervalue: "+request.getExeValue()+"}");
+            }
 
             checkpoint.addRequestBlock(seqnum, block);
             //// benchmarkManager.sequenceStarted(seqnum, DataUtils.timeus());
@@ -1114,6 +1155,8 @@
 
     protected abstract void execute(long seqnum);
 
+    protected abstract void xov_execute(MessageData message);
+
     public abstract boolean isClient();
 
     // Getters
Index: scripts/local_exp.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Usage: ./local_exp.sh [protocol] [learning (optional)]\n# Examples:\n#        ./local_exp.sh pbft # run pbft without learning agents\n#        ./local_exp.sh pbft # run bedrock with learning agents, using pbft as the default protocol\n# [protocol]: protocol name to run\n# [learning]: if *learning* provided, each bedrock entity will be paired with a local learning agent\n\nprotocol=$1\n\n\ncount=6 # 3f+3\nagent_count=0\n# if learning, agent_count=count-2\nif [ $# -gt 1 ]; then\n  if [ \"$2\" == \"learning\" ]; then\n    agent_count=$((count-2))\n  fi\nfi\n\n# check if session exists\nif tmux has-session -t cloudlab 2>/dev/null; then\n  # session exists - kill it\n  tmux kill-session -t cloudlab\nfi\nif tmux has-session -t cloudlab-learning 2>/dev/null; then\n  # session exists - kill it\n  tmux kill-session -t cloudlab-learning\nfi\n\n# create new session\ntmux new-session -d -s cloudlab\nif [ $agent_count -gt 0 ]; then\n  tmux new-session -d -s cloudlab-learning\nfi\n\n# create one window for each server\nfor (( i=0; i<$count-1; i++ ))\ndo\n  tmux new-window -t cloudlab\ndone\nfor (( i=0; i<$agent_count-1; i++ ))\ndo\n  tmux new-window -t cloudlab-learning\ndone\n\n\nsleep 5\n\necho \"\\033[4;34mStart running $protocol with $count servers\\033[m\"\n\necho \"Protocol $protocol : [0/6] Killing previous processes if needed ...\"\n\nfor (( i=0; i<$count; i++ ))\ndo\n  echo \"Killing Bedrock and learning agent on machine $i ...\"\n  tmux send-keys -t cloudlab:\"$i\" \"cd ~/BFTBrain/code && ../scripts/kill_process_port.sh $((9020+$count)) && ../scripts/kill_process_port.sh $((9020+$count+20))\" C-m\ndone\n\necho \"Protocol $protocol : [1/6] Starting Coordination Server\"\n# start server on the first server\ntmux send-keys -t cloudlab:0 \"./run.sh CoordinatorServer -p 9020 -r $protocol\" C-m\n\necho \"Protocol $protocol : [2/6] Waiting for 10 seconds for coordination server to set up ...\"\nsleep 5\n\n# start units\nfor (( i=1; i<$count-1; i++ ))\ndo\n  echo \"Protocol $protocol : [3/6] Starting Coordination Unit $(($i-1))\"\n  tmux send-keys -t cloudlab:\"$i\" \"./run.sh CoordinatorUnit -u $(($i-1)) -p $((9020+$i)) -n 1 -s 127.0.0.1:9020\" C-m\n  sleep 1\ndone\n\n# start learning agents\nfor (( i=0; i<$agent_count; i++ ))\ndo\n  echo \"Protocol $protocol : [3/6] Starting Learning Agent for Coordination Unit $i\"\n  tmux send-keys -t cloudlab-learning:\"$i\" \"cd ~/BFTBrain/code/learning/ && python3 learning_agent.py -u $i -p $((9021+$i)) -n single\" C-m\ndone\nsleep 5\n\necho \"Protocol $protocol : [4/6] Starting Client\"\n# start client\ntmux send-keys -t cloudlab:\"$(($count-1))\" \"./run.sh CoordinatorUnit -u $(($count-2)) -p $((9020+$count-1)) -c 1 -s 127.0.0.1:9020\" C-m\n\necho \"Protocol $protocol : [5/6] Waiting for 10 seconds for connection to set up ...\"\nsleep 5\n\n# coordination server start\ntmux send-keys -t cloudlab:0 C-m\n\necho \"Protocol $protocol : [6/6] Executing ...\"\n\necho \"WAITING FOR INPUT TO KILL THE INSTANCE\"\ncat\n\nfor (( i=0; i<$count; i++ ))\ndo\n  echo \"Stopping Bedrock on machine $i ...\"\n  tmux send-keys -t cloudlab:\"$i\" C-c\ndone\nfor (( i=0; i<$agent_count; i++ ))\ndo\n  tmux send-keys -t cloudlab-learning:\"$i\" C-c\ndone\n\necho \"Protocol $protocol : [Finish]\"\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/scripts/local_exp.sh b/scripts/local_exp.sh
--- a/scripts/local_exp.sh	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/scripts/local_exp.sh	(date 1711218368433)
@@ -53,7 +53,7 @@
 for (( i=0; i<$count; i++ ))
 do
   echo "Killing Bedrock and learning agent on machine $i ..."
-  tmux send-keys -t cloudlab:"$i" "cd ~/BFTBrain/code && ../scripts/kill_process_port.sh $((9020+$count)) && ../scripts/kill_process_port.sh $((9020+$count+20))" C-m
+  tmux send-keys -t cloudlab:"$i" "cd /Users/sai/Desktop/Project_P/BFTBrain/code && ../scripts/kill_process_port.sh $((9020+$count)) && ../scripts/kill_process_port.sh $((9020+$count+20))" C-m
 done
 
 echo "Protocol $protocol : [1/6] Starting Coordination Server"
@@ -75,7 +75,7 @@
 for (( i=0; i<$agent_count; i++ ))
 do
   echo "Protocol $protocol : [3/6] Starting Learning Agent for Coordination Unit $i"
-  tmux send-keys -t cloudlab-learning:"$i" "cd ~/BFTBrain/code/learning/ && python3 learning_agent.py -u $i -p $((9021+$i)) -n single" C-m
+  tmux send-keys -t cloudlab-learning:"$i" "cd /Users/sai/Desktop/Project_P/BFTBrain/code/learning/ && python3 learning_agent.py -u $i -p $((9021+$i)) -n single" C-m
 done
 sleep 5
 
Index: code/src/com/gbft/framework/utils/CheckpointManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\n\nimport com.gbft.framework.core.Entity;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.google.protobuf.ByteString;\n\npublic class CheckpointManager {\n\n    private Entity entity;\n    private int CHECKPOINT;\n    private int checkpointSize;\n    private ConcurrentSkipListMap<Long, CheckpointData> checkpoints;\n    private long lastStableCheckpoint; // s\n    private long lowWaterMark; // h\n    public final int lowHighGap; // k\n\n    public CheckpointManager(Entity entity) {\n        this.entity = entity;\n\n        CHECKPOINT = StateMachine.messages.indexOf(StateMachine.findMessage(\"checkpoint\"));\n        checkpointSize = Config.integer(\"benchmark.checkpoint-size\");\n        lowHighGap = Config.integer(\"benchmark.catch-up-k\");\n        lastStableCheckpoint = -1;\n        lowWaterMark = 0;\n\n        checkpoints = new ConcurrentSkipListMap<>();\n        checkpoints.put(0L, new CheckpointData(0, this.entity));\n    }\n\n    /**\n     * Send Checkpoint Message\n     * @param checkpointNum Sequence Number / Checkpoint Size\n     */\n    public void sendCheckpoint(long checkpointNum) {\n        // System.out.println(entity.prefix + \"sendCheckpoint, checkpointNum:  \" + checkpointNum);\n\n        var digest = getCheckpointDigest(checkpointNum);\n        var targets = entity.getRolePlugin().getRoleEntities(0, 0, StateMachine.NORMAL_PHASE, StateMachine.NODE);\n        var message = DataUtils.createMessage(checkpointNum, 0L, CHECKPOINT, entity.getId(), targets, List.of(),\n                entity.EMPTY_BLOCK, null, digest);\n        entity.sendMessage(message);       \n    } \n\n    public ByteString getCheckpointDigest(long checkpointNum) {\n        var stream = new ByteArrayOutputStream();\n        try {\n            var checkpoint = getCheckpoint(checkpointNum);\n            for (var entry : checkpoint.serviceState.getRecords().entrySet()) {\n                stream.write(entry.getKey().byteValue());\n                stream.write(entry.getValue().byteValue());\n            }\n\n            stream.flush();\n            stream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return DataUtils.getDigest(stream.toByteArray());\n    }\n\n    public ByteString getCheckpointDigest(Map<Integer, Integer> state) {\n        var stream = new ByteArrayOutputStream();\n        Map<Integer, Integer> sorted_state = new TreeMap<>();\n        state.forEach((key, value) -> sorted_state.put(key, value));\n\n        try {\n            for (var entry : sorted_state.entrySet()) {\n                stream.write(entry.getKey().byteValue());\n                stream.write(entry.getValue().byteValue());\n            }\n\n            stream.flush();\n            stream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return DataUtils.getDigest(stream.toByteArray());\n    }\n\n    public void setLastStableCheckpoint(long checkpointNum) {\n        lastStableCheckpoint = checkpointNum;\n    }\n\n    public Long getLastStableCheckpoint() {\n        return lastStableCheckpoint;\n    }\n\n    public void setLowWaterMark(long h) {\n        lowWaterMark = h;\n    }\n\n    public long getLowWaterMark() {\n        return lowWaterMark;\n    }\n\n    public Long getMinCheckpoint() {\n        return checkpoints.firstKey();\n    }\n\n    public Long getMaxCheckpoint() {\n        return checkpoints.lastKey();\n    }\n\n    public CheckpointData getCheckpoint(long checkpointNum) {\n        return checkpoints.computeIfAbsent(checkpointNum, num -> new CheckpointData(num, this.entity));\n    }\n\n    public void removeCheckpoint(long checkpointNum) {\n        checkpoints.remove(checkpointNum);\n    }\n\n    public long getCheckpointNum(long seqnum) {\n        return seqnum / checkpointSize;\n    }\n\n    /**\n     * Everything tallied in checkpoint\n     * @param seqnum sequence number\n     * @return checkpoint that is responsible for seqnum\n     */\n    public CheckpointData getCheckpointForSeq(long seqnum) {\n        return getCheckpoint(seqnum / checkpointSize);\n    }\n\n    public CheckpointData getPrevCheckpointForSeq(long seqnum) {\n        return getCheckpoint(seqnum / checkpointSize - 1);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/utils/CheckpointManager.java b/code/src/com/gbft/framework/utils/CheckpointManager.java
--- a/code/src/com/gbft/framework/utils/CheckpointManager.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/utils/CheckpointManager.java	(date 1713847615522)
@@ -45,8 +45,12 @@
         var targets = entity.getRolePlugin().getRoleEntities(0, 0, StateMachine.NORMAL_PHASE, StateMachine.NODE);
         var message = DataUtils.createMessage(checkpointNum, 0L, CHECKPOINT, entity.getId(), targets, List.of(),
                 entity.EMPTY_BLOCK, null, digest);
-        entity.sendMessage(message);       
-    } 
+//        var requests=message.getRequestsList();
+//        for(var request:requests){
+//            entity.l.write(entity.getId(), "\n{\nsingle_request_1:"+request.toString()+"\nvalue_1: "+request.getExeValue()+"}");
+//        }
+        entity.sendMessage(message);
+    }
 
     public ByteString getCheckpointDigest(long checkpointNum) {
         var stream = new ByteArrayOutputStream();
Index: code/src/com/gbft/framework/data/RequestData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Generated by the protocol buffer compiler.  DO NOT EDIT!\n// source: gbft.proto\n\npackage com.gbft.framework.data;\n\n/**\n * Protobuf type {@code RequestData}\n */\npublic final class RequestData extends\n    com.google.protobuf.GeneratedMessageV3 implements\n    // @@protoc_insertion_point(message_implements:RequestData)\n    RequestDataOrBuilder {\nprivate static final long serialVersionUID = 0L;\n  // Use RequestData.newBuilder() to construct.\n  private RequestData(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n    super(builder);\n  }\n  private RequestData() {\n    operation_ = 0;\n    reportQuorum_ = java.util.Collections.emptyList();\n    requestDummy_ = com.google.protobuf.ByteString.EMPTY;\n  }\n\n  @java.lang.Override\n  @SuppressWarnings({\"unused\"})\n  protected java.lang.Object newInstance(\n      UnusedPrivateParameter unused) {\n    return new RequestData();\n  }\n\n  @java.lang.Override\n  public final com.google.protobuf.UnknownFieldSet\n  getUnknownFields() {\n    return this.unknownFields;\n  }\n  private RequestData(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    this();\n    if (extensionRegistry == null) {\n      throw new java.lang.NullPointerException();\n    }\n    int mutable_bitField0_ = 0;\n    com.google.protobuf.UnknownFieldSet.Builder unknownFields =\n        com.google.protobuf.UnknownFieldSet.newBuilder();\n    try {\n      boolean done = false;\n      while (!done) {\n        int tag = input.readTag();\n        switch (tag) {\n          case 0:\n            done = true;\n            break;\n          case 8: {\n\n            client_ = input.readInt32();\n            break;\n          }\n          case 16: {\n\n            requestNum_ = input.readInt64();\n            break;\n          }\n          case 24: {\n\n            record_ = input.readInt32();\n            break;\n          }\n          case 32: {\n            int rawValue = input.readEnum();\n\n            operation_ = rawValue;\n            break;\n          }\n          case 40: {\n\n            value_ = input.readInt32();\n            break;\n          }\n          case 50: {\n            com.google.protobuf.Timestamp.Builder subBuilder = null;\n            if (timestamp_ != null) {\n              subBuilder = timestamp_.toBuilder();\n            }\n            timestamp_ = input.readMessage(com.google.protobuf.Timestamp.parser(), extensionRegistry);\n            if (subBuilder != null) {\n              subBuilder.mergeFrom(timestamp_);\n              timestamp_ = subBuilder.buildPartial();\n            }\n\n            break;\n          }\n          case 58: {\n            if (!((mutable_bitField0_ & 0x00000001) != 0)) {\n              reportQuorum_ = new java.util.ArrayList<com.gbft.framework.data.LearningData>();\n              mutable_bitField0_ |= 0x00000001;\n            }\n            reportQuorum_.add(\n                input.readMessage(com.gbft.framework.data.LearningData.parser(), extensionRegistry));\n            break;\n          }\n          case 66: {\n\n            requestDummy_ = input.readBytes();\n            break;\n          }\n          case 72: {\n\n            computeFactor_ = input.readInt32();\n            break;\n          }\n          case 80: {\n\n            replySize_ = input.readInt32();\n            break;\n          }\n          default: {\n            if (!parseUnknownField(\n                input, unknownFields, extensionRegistry, tag)) {\n              done = true;\n            }\n            break;\n          }\n        }\n      }\n    } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n      throw e.setUnfinishedMessage(this);\n    } catch (java.io.IOException e) {\n      throw new com.google.protobuf.InvalidProtocolBufferException(\n          e).setUnfinishedMessage(this);\n    } finally {\n      if (((mutable_bitField0_ & 0x00000001) != 0)) {\n        reportQuorum_ = java.util.Collections.unmodifiableList(reportQuorum_);\n      }\n      this.unknownFields = unknownFields.build();\n      makeExtensionsImmutable();\n    }\n  }\n  public static final com.google.protobuf.Descriptors.Descriptor\n      getDescriptor() {\n    return com.gbft.framework.data.Gbft.internal_static_RequestData_descriptor;\n  }\n\n  @java.lang.Override\n  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internalGetFieldAccessorTable() {\n    return com.gbft.framework.data.Gbft.internal_static_RequestData_fieldAccessorTable\n        .ensureFieldAccessorsInitialized(\n            com.gbft.framework.data.RequestData.class, com.gbft.framework.data.RequestData.Builder.class);\n  }\n\n  /**\n   * Protobuf enum {@code RequestData.Operation}\n   */\n  public enum Operation\n      implements com.google.protobuf.ProtocolMessageEnum {\n    /**\n     * <code>NOP = 0;</code>\n     */\n    NOP(0),\n    /**\n     * <code>ADD = 1;</code>\n     */\n    ADD(1),\n    /**\n     * <code>SUB = 2;</code>\n     */\n    SUB(2),\n    /**\n     * <code>INC = 3;</code>\n     */\n    INC(3),\n    /**\n     * <code>DEC = 4;</code>\n     */\n    DEC(4),\n    /**\n     * <code>READ_ONLY = 5;</code>\n     */\n    READ_ONLY(5),\n    UNRECOGNIZED(-1),\n    ;\n\n    /**\n     * <code>NOP = 0;</code>\n     */\n    public static final int NOP_VALUE = 0;\n    /**\n     * <code>ADD = 1;</code>\n     */\n    public static final int ADD_VALUE = 1;\n    /**\n     * <code>SUB = 2;</code>\n     */\n    public static final int SUB_VALUE = 2;\n    /**\n     * <code>INC = 3;</code>\n     */\n    public static final int INC_VALUE = 3;\n    /**\n     * <code>DEC = 4;</code>\n     */\n    public static final int DEC_VALUE = 4;\n    /**\n     * <code>READ_ONLY = 5;</code>\n     */\n    public static final int READ_ONLY_VALUE = 5;\n\n\n    public final int getNumber() {\n      if (this == UNRECOGNIZED) {\n        throw new java.lang.IllegalArgumentException(\n            \"Can't get the number of an unknown enum value.\");\n      }\n      return value;\n    }\n\n    /**\n     * @param value The numeric wire value of the corresponding enum entry.\n     * @return The enum associated with the given numeric wire value.\n     * @deprecated Use {@link #forNumber(int)} instead.\n     */\n    @java.lang.Deprecated\n    public static Operation valueOf(int value) {\n      return forNumber(value);\n    }\n\n    /**\n     * @param value The numeric wire value of the corresponding enum entry.\n     * @return The enum associated with the given numeric wire value.\n     */\n    public static Operation forNumber(int value) {\n      switch (value) {\n        case 0: return NOP;\n        case 1: return ADD;\n        case 2: return SUB;\n        case 3: return INC;\n        case 4: return DEC;\n        case 5: return READ_ONLY;\n        default: return null;\n      }\n    }\n\n    public static com.google.protobuf.Internal.EnumLiteMap<Operation>\n        internalGetValueMap() {\n      return internalValueMap;\n    }\n    private static final com.google.protobuf.Internal.EnumLiteMap<\n        Operation> internalValueMap =\n          new com.google.protobuf.Internal.EnumLiteMap<Operation>() {\n            public Operation findValueByNumber(int number) {\n              return Operation.forNumber(number);\n            }\n          };\n\n    public final com.google.protobuf.Descriptors.EnumValueDescriptor\n        getValueDescriptor() {\n      if (this == UNRECOGNIZED) {\n        throw new java.lang.IllegalStateException(\n            \"Can't get the descriptor of an unrecognized enum value.\");\n      }\n      return getDescriptor().getValues().get(ordinal());\n    }\n    public final com.google.protobuf.Descriptors.EnumDescriptor\n        getDescriptorForType() {\n      return getDescriptor();\n    }\n    public static final com.google.protobuf.Descriptors.EnumDescriptor\n        getDescriptor() {\n      return com.gbft.framework.data.RequestData.getDescriptor().getEnumTypes().get(0);\n    }\n\n    private static final Operation[] VALUES = values();\n\n    public static Operation valueOf(\n        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {\n      if (desc.getType() != getDescriptor()) {\n        throw new java.lang.IllegalArgumentException(\n          \"EnumValueDescriptor is not for this type.\");\n      }\n      if (desc.getIndex() == -1) {\n        return UNRECOGNIZED;\n      }\n      return VALUES[desc.getIndex()];\n    }\n\n    private final int value;\n\n    private Operation(int value) {\n      this.value = value;\n    }\n\n    // @@protoc_insertion_point(enum_scope:RequestData.Operation)\n  }\n\n  public static final int CLIENT_FIELD_NUMBER = 1;\n  private int client_;\n  /**\n   * <code>int32 client = 1;</code>\n   * @return The client.\n   */\n  @java.lang.Override\n  public int getClient() {\n    return client_;\n  }\n\n  public static final int REQUEST_NUM_FIELD_NUMBER = 2;\n  private long requestNum_;\n  /**\n   * <code>int64 request_num = 2;</code>\n   * @return The requestNum.\n   */\n  @java.lang.Override\n  public long getRequestNum() {\n    return requestNum_;\n  }\n\n  public static final int RECORD_FIELD_NUMBER = 3;\n  private int record_;\n  /**\n   * <code>int32 record = 3;</code>\n   * @return The record.\n   */\n  @java.lang.Override\n  public int getRecord() {\n    return record_;\n  }\n\n  public static final int OPERATION_FIELD_NUMBER = 4;\n  private int operation_;\n  /**\n   * <code>.RequestData.Operation operation = 4;</code>\n   * @return The enum numeric value on the wire for operation.\n   */\n  @java.lang.Override public int getOperationValue() {\n    return operation_;\n  }\n  /**\n   * <code>.RequestData.Operation operation = 4;</code>\n   * @return The operation.\n   */\n  @java.lang.Override public com.gbft.framework.data.RequestData.Operation getOperation() {\n    @SuppressWarnings(\"deprecation\")\n    com.gbft.framework.data.RequestData.Operation result = com.gbft.framework.data.RequestData.Operation.valueOf(operation_);\n    return result == null ? com.gbft.framework.data.RequestData.Operation.UNRECOGNIZED : result;\n  }\n\n  public static final int VALUE_FIELD_NUMBER = 5;\n  private int value_;\n  /**\n   * <code>int32 value = 5;</code>\n   * @return The value.\n   */\n  @java.lang.Override\n  public int getValue() {\n    return value_;\n  }\n\n  public static final int TIMESTAMP_FIELD_NUMBER = 6;\n  private com.google.protobuf.Timestamp timestamp_;\n  /**\n   * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n   * @return Whether the timestamp field is set.\n   */\n  @java.lang.Override\n  public boolean hasTimestamp() {\n    return timestamp_ != null;\n  }\n  /**\n   * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n   * @return The timestamp.\n   */\n  @java.lang.Override\n  public com.google.protobuf.Timestamp getTimestamp() {\n    return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;\n  }\n  /**\n   * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n   */\n  @java.lang.Override\n  public com.google.protobuf.TimestampOrBuilder getTimestampOrBuilder() {\n    return getTimestamp();\n  }\n\n  public static final int REPORT_QUORUM_FIELD_NUMBER = 7;\n  private java.util.List<com.gbft.framework.data.LearningData> reportQuorum_;\n  /**\n   * <code>repeated .LearningData report_quorum = 7;</code>\n   */\n  @java.lang.Override\n  public java.util.List<com.gbft.framework.data.LearningData> getReportQuorumList() {\n    return reportQuorum_;\n  }\n  /**\n   * <code>repeated .LearningData report_quorum = 7;</code>\n   */\n  @java.lang.Override\n  public java.util.List<? extends com.gbft.framework.data.LearningDataOrBuilder> \n      getReportQuorumOrBuilderList() {\n    return reportQuorum_;\n  }\n  /**\n   * <code>repeated .LearningData report_quorum = 7;</code>\n   */\n  @java.lang.Override\n  public int getReportQuorumCount() {\n    return reportQuorum_.size();\n  }\n  /**\n   * <code>repeated .LearningData report_quorum = 7;</code>\n   */\n  @java.lang.Override\n  public com.gbft.framework.data.LearningData getReportQuorum(int index) {\n    return reportQuorum_.get(index);\n  }\n  /**\n   * <code>repeated .LearningData report_quorum = 7;</code>\n   */\n  @java.lang.Override\n  public com.gbft.framework.data.LearningDataOrBuilder getReportQuorumOrBuilder(\n      int index) {\n    return reportQuorum_.get(index);\n  }\n\n  public static final int REQUEST_DUMMY_FIELD_NUMBER = 8;\n  private com.google.protobuf.ByteString requestDummy_;\n  /**\n   * <code>bytes request_dummy = 8;</code>\n   * @return The requestDummy.\n   */\n  @java.lang.Override\n  public com.google.protobuf.ByteString getRequestDummy() {\n    return requestDummy_;\n  }\n\n  public static final int COMPUTE_FACTOR_FIELD_NUMBER = 9;\n  private int computeFactor_;\n  /**\n   * <code>int32 compute_factor = 9;</code>\n   * @return The computeFactor.\n   */\n  @java.lang.Override\n  public int getComputeFactor() {\n    return computeFactor_;\n  }\n\n  public static final int REPLY_SIZE_FIELD_NUMBER = 10;\n  private int replySize_;\n  /**\n   * <code>int32 reply_size = 10;</code>\n   * @return The replySize.\n   */\n  @java.lang.Override\n  public int getReplySize() {\n    return replySize_;\n  }\n\n  private byte memoizedIsInitialized = -1;\n  @java.lang.Override\n  public final boolean isInitialized() {\n    byte isInitialized = memoizedIsInitialized;\n    if (isInitialized == 1) return true;\n    if (isInitialized == 0) return false;\n\n    memoizedIsInitialized = 1;\n    return true;\n  }\n\n  @java.lang.Override\n  public void writeTo(com.google.protobuf.CodedOutputStream output)\n                      throws java.io.IOException {\n    if (client_ != 0) {\n      output.writeInt32(1, client_);\n    }\n    if (requestNum_ != 0L) {\n      output.writeInt64(2, requestNum_);\n    }\n    if (record_ != 0) {\n      output.writeInt32(3, record_);\n    }\n    if (operation_ != com.gbft.framework.data.RequestData.Operation.NOP.getNumber()) {\n      output.writeEnum(4, operation_);\n    }\n    if (value_ != 0) {\n      output.writeInt32(5, value_);\n    }\n    if (timestamp_ != null) {\n      output.writeMessage(6, getTimestamp());\n    }\n    for (int i = 0; i < reportQuorum_.size(); i++) {\n      output.writeMessage(7, reportQuorum_.get(i));\n    }\n    if (!requestDummy_.isEmpty()) {\n      output.writeBytes(8, requestDummy_);\n    }\n    if (computeFactor_ != 0) {\n      output.writeInt32(9, computeFactor_);\n    }\n    if (replySize_ != 0) {\n      output.writeInt32(10, replySize_);\n    }\n    unknownFields.writeTo(output);\n  }\n\n  @java.lang.Override\n  public int getSerializedSize() {\n    int size = memoizedSize;\n    if (size != -1) return size;\n\n    size = 0;\n    if (client_ != 0) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeInt32Size(1, client_);\n    }\n    if (requestNum_ != 0L) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeInt64Size(2, requestNum_);\n    }\n    if (record_ != 0) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeInt32Size(3, record_);\n    }\n    if (operation_ != com.gbft.framework.data.RequestData.Operation.NOP.getNumber()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeEnumSize(4, operation_);\n    }\n    if (value_ != 0) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeInt32Size(5, value_);\n    }\n    if (timestamp_ != null) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeMessageSize(6, getTimestamp());\n    }\n    for (int i = 0; i < reportQuorum_.size(); i++) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeMessageSize(7, reportQuorum_.get(i));\n    }\n    if (!requestDummy_.isEmpty()) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeBytesSize(8, requestDummy_);\n    }\n    if (computeFactor_ != 0) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeInt32Size(9, computeFactor_);\n    }\n    if (replySize_ != 0) {\n      size += com.google.protobuf.CodedOutputStream\n        .computeInt32Size(10, replySize_);\n    }\n    size += unknownFields.getSerializedSize();\n    memoizedSize = size;\n    return size;\n  }\n\n  @java.lang.Override\n  public boolean equals(final java.lang.Object obj) {\n    if (obj == this) {\n     return true;\n    }\n    if (!(obj instanceof com.gbft.framework.data.RequestData)) {\n      return super.equals(obj);\n    }\n    com.gbft.framework.data.RequestData other = (com.gbft.framework.data.RequestData) obj;\n\n    if (getClient()\n        != other.getClient()) return false;\n    if (getRequestNum()\n        != other.getRequestNum()) return false;\n    if (getRecord()\n        != other.getRecord()) return false;\n    if (operation_ != other.operation_) return false;\n    if (getValue()\n        != other.getValue()) return false;\n    if (hasTimestamp() != other.hasTimestamp()) return false;\n    if (hasTimestamp()) {\n      if (!getTimestamp()\n          .equals(other.getTimestamp())) return false;\n    }\n    if (!getReportQuorumList()\n        .equals(other.getReportQuorumList())) return false;\n    if (!getRequestDummy()\n        .equals(other.getRequestDummy())) return false;\n    if (getComputeFactor()\n        != other.getComputeFactor()) return false;\n    if (getReplySize()\n        != other.getReplySize()) return false;\n    if (!unknownFields.equals(other.unknownFields)) return false;\n    return true;\n  }\n\n  @java.lang.Override\n  public int hashCode() {\n    if (memoizedHashCode != 0) {\n      return memoizedHashCode;\n    }\n    int hash = 41;\n    hash = (19 * hash) + getDescriptor().hashCode();\n    hash = (37 * hash) + CLIENT_FIELD_NUMBER;\n    hash = (53 * hash) + getClient();\n    hash = (37 * hash) + REQUEST_NUM_FIELD_NUMBER;\n    hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n        getRequestNum());\n    hash = (37 * hash) + RECORD_FIELD_NUMBER;\n    hash = (53 * hash) + getRecord();\n    hash = (37 * hash) + OPERATION_FIELD_NUMBER;\n    hash = (53 * hash) + operation_;\n    hash = (37 * hash) + VALUE_FIELD_NUMBER;\n    hash = (53 * hash) + getValue();\n    if (hasTimestamp()) {\n      hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;\n      hash = (53 * hash) + getTimestamp().hashCode();\n    }\n    if (getReportQuorumCount() > 0) {\n      hash = (37 * hash) + REPORT_QUORUM_FIELD_NUMBER;\n      hash = (53 * hash) + getReportQuorumList().hashCode();\n    }\n    hash = (37 * hash) + REQUEST_DUMMY_FIELD_NUMBER;\n    hash = (53 * hash) + getRequestDummy().hashCode();\n    hash = (37 * hash) + COMPUTE_FACTOR_FIELD_NUMBER;\n    hash = (53 * hash) + getComputeFactor();\n    hash = (37 * hash) + REPLY_SIZE_FIELD_NUMBER;\n    hash = (53 * hash) + getReplySize();\n    hash = (29 * hash) + unknownFields.hashCode();\n    memoizedHashCode = hash;\n    return hash;\n  }\n\n  public static com.gbft.framework.data.RequestData parseFrom(\n      java.nio.ByteBuffer data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(\n      java.nio.ByteBuffer data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(\n      com.google.protobuf.ByteString data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(\n      com.google.protobuf.ByteString data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(byte[] data)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(\n      byte[] data,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws com.google.protobuf.InvalidProtocolBufferException {\n    return PARSER.parseFrom(data, extensionRegistry);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static com.gbft.framework.data.RequestData parseDelimitedFrom(java.io.InputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input);\n  }\n  public static com.gbft.framework.data.RequestData parseDelimitedFrom(\n      java.io.InputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(\n      com.google.protobuf.CodedInputStream input)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input);\n  }\n  public static com.gbft.framework.data.RequestData parseFrom(\n      com.google.protobuf.CodedInputStream input,\n      com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n      throws java.io.IOException {\n    return com.google.protobuf.GeneratedMessageV3\n        .parseWithIOException(PARSER, input, extensionRegistry);\n  }\n\n  @java.lang.Override\n  public Builder newBuilderForType() { return newBuilder(); }\n  public static Builder newBuilder() {\n    return DEFAULT_INSTANCE.toBuilder();\n  }\n  public static Builder newBuilder(com.gbft.framework.data.RequestData prototype) {\n    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n  }\n  @java.lang.Override\n  public Builder toBuilder() {\n    return this == DEFAULT_INSTANCE\n        ? new Builder() : new Builder().mergeFrom(this);\n  }\n\n  @java.lang.Override\n  protected Builder newBuilderForType(\n      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n    Builder builder = new Builder(parent);\n    return builder;\n  }\n  /**\n   * Protobuf type {@code RequestData}\n   */\n  public static final class Builder extends\n      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n      // @@protoc_insertion_point(builder_implements:RequestData)\n      com.gbft.framework.data.RequestDataOrBuilder {\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return com.gbft.framework.data.Gbft.internal_static_RequestData_descriptor;\n    }\n\n    @java.lang.Override\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return com.gbft.framework.data.Gbft.internal_static_RequestData_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              com.gbft.framework.data.RequestData.class, com.gbft.framework.data.RequestData.Builder.class);\n    }\n\n    // Construct using com.gbft.framework.data.RequestData.newBuilder()\n    private Builder() {\n      maybeForceBuilderInitialization();\n    }\n\n    private Builder(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      super(parent);\n      maybeForceBuilderInitialization();\n    }\n    private void maybeForceBuilderInitialization() {\n      if (com.google.protobuf.GeneratedMessageV3\n              .alwaysUseFieldBuilders) {\n        getReportQuorumFieldBuilder();\n      }\n    }\n    @java.lang.Override\n    public Builder clear() {\n      super.clear();\n      client_ = 0;\n\n      requestNum_ = 0L;\n\n      record_ = 0;\n\n      operation_ = 0;\n\n      value_ = 0;\n\n      if (timestampBuilder_ == null) {\n        timestamp_ = null;\n      } else {\n        timestamp_ = null;\n        timestampBuilder_ = null;\n      }\n      if (reportQuorumBuilder_ == null) {\n        reportQuorum_ = java.util.Collections.emptyList();\n        bitField0_ = (bitField0_ & ~0x00000001);\n      } else {\n        reportQuorumBuilder_.clear();\n      }\n      requestDummy_ = com.google.protobuf.ByteString.EMPTY;\n\n      computeFactor_ = 0;\n\n      replySize_ = 0;\n\n      return this;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Descriptors.Descriptor\n        getDescriptorForType() {\n      return com.gbft.framework.data.Gbft.internal_static_RequestData_descriptor;\n    }\n\n    @java.lang.Override\n    public com.gbft.framework.data.RequestData getDefaultInstanceForType() {\n      return com.gbft.framework.data.RequestData.getDefaultInstance();\n    }\n\n    @java.lang.Override\n    public com.gbft.framework.data.RequestData build() {\n      com.gbft.framework.data.RequestData result = buildPartial();\n      if (!result.isInitialized()) {\n        throw newUninitializedMessageException(result);\n      }\n      return result;\n    }\n\n    @java.lang.Override\n    public com.gbft.framework.data.RequestData buildPartial() {\n      com.gbft.framework.data.RequestData result = new com.gbft.framework.data.RequestData(this);\n      int from_bitField0_ = bitField0_;\n      result.client_ = client_;\n      result.requestNum_ = requestNum_;\n      result.record_ = record_;\n      result.operation_ = operation_;\n      result.value_ = value_;\n      if (timestampBuilder_ == null) {\n        result.timestamp_ = timestamp_;\n      } else {\n        result.timestamp_ = timestampBuilder_.build();\n      }\n      if (reportQuorumBuilder_ == null) {\n        if (((bitField0_ & 0x00000001) != 0)) {\n          reportQuorum_ = java.util.Collections.unmodifiableList(reportQuorum_);\n          bitField0_ = (bitField0_ & ~0x00000001);\n        }\n        result.reportQuorum_ = reportQuorum_;\n      } else {\n        result.reportQuorum_ = reportQuorumBuilder_.build();\n      }\n      result.requestDummy_ = requestDummy_;\n      result.computeFactor_ = computeFactor_;\n      result.replySize_ = replySize_;\n      onBuilt();\n      return result;\n    }\n\n    @java.lang.Override\n    public Builder clone() {\n      return super.clone();\n    }\n    @java.lang.Override\n    public Builder setField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.setField(field, value);\n    }\n    @java.lang.Override\n    public Builder clearField(\n        com.google.protobuf.Descriptors.FieldDescriptor field) {\n      return super.clearField(field);\n    }\n    @java.lang.Override\n    public Builder clearOneof(\n        com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n      return super.clearOneof(oneof);\n    }\n    @java.lang.Override\n    public Builder setRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        int index, java.lang.Object value) {\n      return super.setRepeatedField(field, index, value);\n    }\n    @java.lang.Override\n    public Builder addRepeatedField(\n        com.google.protobuf.Descriptors.FieldDescriptor field,\n        java.lang.Object value) {\n      return super.addRepeatedField(field, value);\n    }\n    @java.lang.Override\n    public Builder mergeFrom(com.google.protobuf.Message other) {\n      if (other instanceof com.gbft.framework.data.RequestData) {\n        return mergeFrom((com.gbft.framework.data.RequestData)other);\n      } else {\n        super.mergeFrom(other);\n        return this;\n      }\n    }\n\n    public Builder mergeFrom(com.gbft.framework.data.RequestData other) {\n      if (other == com.gbft.framework.data.RequestData.getDefaultInstance()) return this;\n      if (other.getClient() != 0) {\n        setClient(other.getClient());\n      }\n      if (other.getRequestNum() != 0L) {\n        setRequestNum(other.getRequestNum());\n      }\n      if (other.getRecord() != 0) {\n        setRecord(other.getRecord());\n      }\n      if (other.operation_ != 0) {\n        setOperationValue(other.getOperationValue());\n      }\n      if (other.getValue() != 0) {\n        setValue(other.getValue());\n      }\n      if (other.hasTimestamp()) {\n        mergeTimestamp(other.getTimestamp());\n      }\n      if (reportQuorumBuilder_ == null) {\n        if (!other.reportQuorum_.isEmpty()) {\n          if (reportQuorum_.isEmpty()) {\n            reportQuorum_ = other.reportQuorum_;\n            bitField0_ = (bitField0_ & ~0x00000001);\n          } else {\n            ensureReportQuorumIsMutable();\n            reportQuorum_.addAll(other.reportQuorum_);\n          }\n          onChanged();\n        }\n      } else {\n        if (!other.reportQuorum_.isEmpty()) {\n          if (reportQuorumBuilder_.isEmpty()) {\n            reportQuorumBuilder_.dispose();\n            reportQuorumBuilder_ = null;\n            reportQuorum_ = other.reportQuorum_;\n            bitField0_ = (bitField0_ & ~0x00000001);\n            reportQuorumBuilder_ = \n              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                 getReportQuorumFieldBuilder() : null;\n          } else {\n            reportQuorumBuilder_.addAllMessages(other.reportQuorum_);\n          }\n        }\n      }\n      if (other.getRequestDummy() != com.google.protobuf.ByteString.EMPTY) {\n        setRequestDummy(other.getRequestDummy());\n      }\n      if (other.getComputeFactor() != 0) {\n        setComputeFactor(other.getComputeFactor());\n      }\n      if (other.getReplySize() != 0) {\n        setReplySize(other.getReplySize());\n      }\n      this.mergeUnknownFields(other.unknownFields);\n      onChanged();\n      return this;\n    }\n\n    @java.lang.Override\n    public final boolean isInitialized() {\n      return true;\n    }\n\n    @java.lang.Override\n    public Builder mergeFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      com.gbft.framework.data.RequestData parsedMessage = null;\n      try {\n        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);\n      } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n        parsedMessage = (com.gbft.framework.data.RequestData) e.getUnfinishedMessage();\n        throw e.unwrapIOException();\n      } finally {\n        if (parsedMessage != null) {\n          mergeFrom(parsedMessage);\n        }\n      }\n      return this;\n    }\n    private int bitField0_;\n\n    private int client_ ;\n    /**\n     * <code>int32 client = 1;</code>\n     * @return The client.\n     */\n    @java.lang.Override\n    public int getClient() {\n      return client_;\n    }\n    /**\n     * <code>int32 client = 1;</code>\n     * @param value The client to set.\n     * @return This builder for chaining.\n     */\n    public Builder setClient(int value) {\n      \n      client_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>int32 client = 1;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearClient() {\n      \n      client_ = 0;\n      onChanged();\n      return this;\n    }\n\n    private long requestNum_ ;\n    /**\n     * <code>int64 request_num = 2;</code>\n     * @return The requestNum.\n     */\n    @java.lang.Override\n    public long getRequestNum() {\n      return requestNum_;\n    }\n    /**\n     * <code>int64 request_num = 2;</code>\n     * @param value The requestNum to set.\n     * @return This builder for chaining.\n     */\n    public Builder setRequestNum(long value) {\n      \n      requestNum_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>int64 request_num = 2;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearRequestNum() {\n      \n      requestNum_ = 0L;\n      onChanged();\n      return this;\n    }\n\n    private int record_ ;\n    /**\n     * <code>int32 record = 3;</code>\n     * @return The record.\n     */\n    @java.lang.Override\n    public int getRecord() {\n      return record_;\n    }\n    /**\n     * <code>int32 record = 3;</code>\n     * @param value The record to set.\n     * @return This builder for chaining.\n     */\n    public Builder setRecord(int value) {\n      \n      record_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>int32 record = 3;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearRecord() {\n      \n      record_ = 0;\n      onChanged();\n      return this;\n    }\n\n    private int operation_ = 0;\n    /**\n     * <code>.RequestData.Operation operation = 4;</code>\n     * @return The enum numeric value on the wire for operation.\n     */\n    @java.lang.Override public int getOperationValue() {\n      return operation_;\n    }\n    /**\n     * <code>.RequestData.Operation operation = 4;</code>\n     * @param value The enum numeric value on the wire for operation to set.\n     * @return This builder for chaining.\n     */\n    public Builder setOperationValue(int value) {\n      \n      operation_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>.RequestData.Operation operation = 4;</code>\n     * @return The operation.\n     */\n    @java.lang.Override\n    public com.gbft.framework.data.RequestData.Operation getOperation() {\n      @SuppressWarnings(\"deprecation\")\n      com.gbft.framework.data.RequestData.Operation result = com.gbft.framework.data.RequestData.Operation.valueOf(operation_);\n      return result == null ? com.gbft.framework.data.RequestData.Operation.UNRECOGNIZED : result;\n    }\n    /**\n     * <code>.RequestData.Operation operation = 4;</code>\n     * @param value The operation to set.\n     * @return This builder for chaining.\n     */\n    public Builder setOperation(com.gbft.framework.data.RequestData.Operation value) {\n      if (value == null) {\n        throw new NullPointerException();\n      }\n      \n      operation_ = value.getNumber();\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>.RequestData.Operation operation = 4;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearOperation() {\n      \n      operation_ = 0;\n      onChanged();\n      return this;\n    }\n\n    private int value_ ;\n    /**\n     * <code>int32 value = 5;</code>\n     * @return The value.\n     */\n    @java.lang.Override\n    public int getValue() {\n      return value_;\n    }\n    /**\n     * <code>int32 value = 5;</code>\n     * @param value The value to set.\n     * @return This builder for chaining.\n     */\n    public Builder setValue(int value) {\n      \n      value_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>int32 value = 5;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearValue() {\n      \n      value_ = 0;\n      onChanged();\n      return this;\n    }\n\n    private com.google.protobuf.Timestamp timestamp_;\n    private com.google.protobuf.SingleFieldBuilderV3<\n        com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> timestampBuilder_;\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     * @return Whether the timestamp field is set.\n     */\n    public boolean hasTimestamp() {\n      return timestampBuilder_ != null || timestamp_ != null;\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     * @return The timestamp.\n     */\n    public com.google.protobuf.Timestamp getTimestamp() {\n      if (timestampBuilder_ == null) {\n        return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;\n      } else {\n        return timestampBuilder_.getMessage();\n      }\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     */\n    public Builder setTimestamp(com.google.protobuf.Timestamp value) {\n      if (timestampBuilder_ == null) {\n        if (value == null) {\n          throw new NullPointerException();\n        }\n        timestamp_ = value;\n        onChanged();\n      } else {\n        timestampBuilder_.setMessage(value);\n      }\n\n      return this;\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     */\n    public Builder setTimestamp(\n        com.google.protobuf.Timestamp.Builder builderForValue) {\n      if (timestampBuilder_ == null) {\n        timestamp_ = builderForValue.build();\n        onChanged();\n      } else {\n        timestampBuilder_.setMessage(builderForValue.build());\n      }\n\n      return this;\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     */\n    public Builder mergeTimestamp(com.google.protobuf.Timestamp value) {\n      if (timestampBuilder_ == null) {\n        if (timestamp_ != null) {\n          timestamp_ =\n            com.google.protobuf.Timestamp.newBuilder(timestamp_).mergeFrom(value).buildPartial();\n        } else {\n          timestamp_ = value;\n        }\n        onChanged();\n      } else {\n        timestampBuilder_.mergeFrom(value);\n      }\n\n      return this;\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     */\n    public Builder clearTimestamp() {\n      if (timestampBuilder_ == null) {\n        timestamp_ = null;\n        onChanged();\n      } else {\n        timestamp_ = null;\n        timestampBuilder_ = null;\n      }\n\n      return this;\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     */\n    public com.google.protobuf.Timestamp.Builder getTimestampBuilder() {\n      \n      onChanged();\n      return getTimestampFieldBuilder().getBuilder();\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     */\n    public com.google.protobuf.TimestampOrBuilder getTimestampOrBuilder() {\n      if (timestampBuilder_ != null) {\n        return timestampBuilder_.getMessageOrBuilder();\n      } else {\n        return timestamp_ == null ?\n            com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;\n      }\n    }\n    /**\n     * <code>.google.protobuf.Timestamp timestamp = 6;</code>\n     */\n    private com.google.protobuf.SingleFieldBuilderV3<\n        com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> \n        getTimestampFieldBuilder() {\n      if (timestampBuilder_ == null) {\n        timestampBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<\n            com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder>(\n                getTimestamp(),\n                getParentForChildren(),\n                isClean());\n        timestamp_ = null;\n      }\n      return timestampBuilder_;\n    }\n\n    private java.util.List<com.gbft.framework.data.LearningData> reportQuorum_ =\n      java.util.Collections.emptyList();\n    private void ensureReportQuorumIsMutable() {\n      if (!((bitField0_ & 0x00000001) != 0)) {\n        reportQuorum_ = new java.util.ArrayList<com.gbft.framework.data.LearningData>(reportQuorum_);\n        bitField0_ |= 0x00000001;\n       }\n    }\n\n    private com.google.protobuf.RepeatedFieldBuilderV3<\n        com.gbft.framework.data.LearningData, com.gbft.framework.data.LearningData.Builder, com.gbft.framework.data.LearningDataOrBuilder> reportQuorumBuilder_;\n\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public java.util.List<com.gbft.framework.data.LearningData> getReportQuorumList() {\n      if (reportQuorumBuilder_ == null) {\n        return java.util.Collections.unmodifiableList(reportQuorum_);\n      } else {\n        return reportQuorumBuilder_.getMessageList();\n      }\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public int getReportQuorumCount() {\n      if (reportQuorumBuilder_ == null) {\n        return reportQuorum_.size();\n      } else {\n        return reportQuorumBuilder_.getCount();\n      }\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public com.gbft.framework.data.LearningData getReportQuorum(int index) {\n      if (reportQuorumBuilder_ == null) {\n        return reportQuorum_.get(index);\n      } else {\n        return reportQuorumBuilder_.getMessage(index);\n      }\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder setReportQuorum(\n        int index, com.gbft.framework.data.LearningData value) {\n      if (reportQuorumBuilder_ == null) {\n        if (value == null) {\n          throw new NullPointerException();\n        }\n        ensureReportQuorumIsMutable();\n        reportQuorum_.set(index, value);\n        onChanged();\n      } else {\n        reportQuorumBuilder_.setMessage(index, value);\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder setReportQuorum(\n        int index, com.gbft.framework.data.LearningData.Builder builderForValue) {\n      if (reportQuorumBuilder_ == null) {\n        ensureReportQuorumIsMutable();\n        reportQuorum_.set(index, builderForValue.build());\n        onChanged();\n      } else {\n        reportQuorumBuilder_.setMessage(index, builderForValue.build());\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder addReportQuorum(com.gbft.framework.data.LearningData value) {\n      if (reportQuorumBuilder_ == null) {\n        if (value == null) {\n          throw new NullPointerException();\n        }\n        ensureReportQuorumIsMutable();\n        reportQuorum_.add(value);\n        onChanged();\n      } else {\n        reportQuorumBuilder_.addMessage(value);\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder addReportQuorum(\n        int index, com.gbft.framework.data.LearningData value) {\n      if (reportQuorumBuilder_ == null) {\n        if (value == null) {\n          throw new NullPointerException();\n        }\n        ensureReportQuorumIsMutable();\n        reportQuorum_.add(index, value);\n        onChanged();\n      } else {\n        reportQuorumBuilder_.addMessage(index, value);\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder addReportQuorum(\n        com.gbft.framework.data.LearningData.Builder builderForValue) {\n      if (reportQuorumBuilder_ == null) {\n        ensureReportQuorumIsMutable();\n        reportQuorum_.add(builderForValue.build());\n        onChanged();\n      } else {\n        reportQuorumBuilder_.addMessage(builderForValue.build());\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder addReportQuorum(\n        int index, com.gbft.framework.data.LearningData.Builder builderForValue) {\n      if (reportQuorumBuilder_ == null) {\n        ensureReportQuorumIsMutable();\n        reportQuorum_.add(index, builderForValue.build());\n        onChanged();\n      } else {\n        reportQuorumBuilder_.addMessage(index, builderForValue.build());\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder addAllReportQuorum(\n        java.lang.Iterable<? extends com.gbft.framework.data.LearningData> values) {\n      if (reportQuorumBuilder_ == null) {\n        ensureReportQuorumIsMutable();\n        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n            values, reportQuorum_);\n        onChanged();\n      } else {\n        reportQuorumBuilder_.addAllMessages(values);\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder clearReportQuorum() {\n      if (reportQuorumBuilder_ == null) {\n        reportQuorum_ = java.util.Collections.emptyList();\n        bitField0_ = (bitField0_ & ~0x00000001);\n        onChanged();\n      } else {\n        reportQuorumBuilder_.clear();\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public Builder removeReportQuorum(int index) {\n      if (reportQuorumBuilder_ == null) {\n        ensureReportQuorumIsMutable();\n        reportQuorum_.remove(index);\n        onChanged();\n      } else {\n        reportQuorumBuilder_.remove(index);\n      }\n      return this;\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public com.gbft.framework.data.LearningData.Builder getReportQuorumBuilder(\n        int index) {\n      return getReportQuorumFieldBuilder().getBuilder(index);\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public com.gbft.framework.data.LearningDataOrBuilder getReportQuorumOrBuilder(\n        int index) {\n      if (reportQuorumBuilder_ == null) {\n        return reportQuorum_.get(index);  } else {\n        return reportQuorumBuilder_.getMessageOrBuilder(index);\n      }\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public java.util.List<? extends com.gbft.framework.data.LearningDataOrBuilder> \n         getReportQuorumOrBuilderList() {\n      if (reportQuorumBuilder_ != null) {\n        return reportQuorumBuilder_.getMessageOrBuilderList();\n      } else {\n        return java.util.Collections.unmodifiableList(reportQuorum_);\n      }\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public com.gbft.framework.data.LearningData.Builder addReportQuorumBuilder() {\n      return getReportQuorumFieldBuilder().addBuilder(\n          com.gbft.framework.data.LearningData.getDefaultInstance());\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public com.gbft.framework.data.LearningData.Builder addReportQuorumBuilder(\n        int index) {\n      return getReportQuorumFieldBuilder().addBuilder(\n          index, com.gbft.framework.data.LearningData.getDefaultInstance());\n    }\n    /**\n     * <code>repeated .LearningData report_quorum = 7;</code>\n     */\n    public java.util.List<com.gbft.framework.data.LearningData.Builder> \n         getReportQuorumBuilderList() {\n      return getReportQuorumFieldBuilder().getBuilderList();\n    }\n    private com.google.protobuf.RepeatedFieldBuilderV3<\n        com.gbft.framework.data.LearningData, com.gbft.framework.data.LearningData.Builder, com.gbft.framework.data.LearningDataOrBuilder> \n        getReportQuorumFieldBuilder() {\n      if (reportQuorumBuilder_ == null) {\n        reportQuorumBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n            com.gbft.framework.data.LearningData, com.gbft.framework.data.LearningData.Builder, com.gbft.framework.data.LearningDataOrBuilder>(\n                reportQuorum_,\n                ((bitField0_ & 0x00000001) != 0),\n                getParentForChildren(),\n                isClean());\n        reportQuorum_ = null;\n      }\n      return reportQuorumBuilder_;\n    }\n\n    private com.google.protobuf.ByteString requestDummy_ = com.google.protobuf.ByteString.EMPTY;\n    /**\n     * <code>bytes request_dummy = 8;</code>\n     * @return The requestDummy.\n     */\n    @java.lang.Override\n    public com.google.protobuf.ByteString getRequestDummy() {\n      return requestDummy_;\n    }\n    /**\n     * <code>bytes request_dummy = 8;</code>\n     * @param value The requestDummy to set.\n     * @return This builder for chaining.\n     */\n    public Builder setRequestDummy(com.google.protobuf.ByteString value) {\n      if (value == null) {\n    throw new NullPointerException();\n  }\n  \n      requestDummy_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>bytes request_dummy = 8;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearRequestDummy() {\n      \n      requestDummy_ = getDefaultInstance().getRequestDummy();\n      onChanged();\n      return this;\n    }\n\n    private int computeFactor_ ;\n    /**\n     * <code>int32 compute_factor = 9;</code>\n     * @return The computeFactor.\n     */\n    @java.lang.Override\n    public int getComputeFactor() {\n      return computeFactor_;\n    }\n    /**\n     * <code>int32 compute_factor = 9;</code>\n     * @param value The computeFactor to set.\n     * @return This builder for chaining.\n     */\n    public Builder setComputeFactor(int value) {\n      \n      computeFactor_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>int32 compute_factor = 9;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearComputeFactor() {\n      \n      computeFactor_ = 0;\n      onChanged();\n      return this;\n    }\n\n    private int replySize_ ;\n    /**\n     * <code>int32 reply_size = 10;</code>\n     * @return The replySize.\n     */\n    @java.lang.Override\n    public int getReplySize() {\n      return replySize_;\n    }\n    /**\n     * <code>int32 reply_size = 10;</code>\n     * @param value The replySize to set.\n     * @return This builder for chaining.\n     */\n    public Builder setReplySize(int value) {\n      \n      replySize_ = value;\n      onChanged();\n      return this;\n    }\n    /**\n     * <code>int32 reply_size = 10;</code>\n     * @return This builder for chaining.\n     */\n    public Builder clearReplySize() {\n      \n      replySize_ = 0;\n      onChanged();\n      return this;\n    }\n    @java.lang.Override\n    public final Builder setUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.setUnknownFields(unknownFields);\n    }\n\n    @java.lang.Override\n    public final Builder mergeUnknownFields(\n        final com.google.protobuf.UnknownFieldSet unknownFields) {\n      return super.mergeUnknownFields(unknownFields);\n    }\n\n\n    // @@protoc_insertion_point(builder_scope:RequestData)\n  }\n\n  // @@protoc_insertion_point(class_scope:RequestData)\n  private static final com.gbft.framework.data.RequestData DEFAULT_INSTANCE;\n  static {\n    DEFAULT_INSTANCE = new com.gbft.framework.data.RequestData();\n  }\n\n  public static com.gbft.framework.data.RequestData getDefaultInstance() {\n    return DEFAULT_INSTANCE;\n  }\n\n  private static final com.google.protobuf.Parser<RequestData>\n      PARSER = new com.google.protobuf.AbstractParser<RequestData>() {\n    @java.lang.Override\n    public RequestData parsePartialFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return new RequestData(input, extensionRegistry);\n    }\n  };\n\n  public static com.google.protobuf.Parser<RequestData> parser() {\n    return PARSER;\n  }\n\n  @java.lang.Override\n  public com.google.protobuf.Parser<RequestData> getParserForType() {\n    return PARSER;\n  }\n\n  @java.lang.Override\n  public com.gbft.framework.data.RequestData getDefaultInstanceForType() {\n    return DEFAULT_INSTANCE;\n  }\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/data/RequestData.java b/code/src/com/gbft/framework/data/RequestData.java
--- a/code/src/com/gbft/framework/data/RequestData.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/data/RequestData.java	(date 1713844277792)
@@ -1647,5 +1647,21 @@
     return DEFAULT_INSTANCE;
   }
 
+  public int exeValue = 10;
+
+  public int getExeValue() {
+    return exeValue;
+  }
+
+  public void setExeValue(int exeValue) {
+    this.exeValue = exeValue;
+  }
+
+
+
+
+
+
+
 }
 
Index: code/src/com/gbft/framework/coordination/CoordinatorServer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.coordination;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.stream.Stream;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.commons.lang3.StringUtils;\n\nimport com.gbft.framework.data.Event;\nimport com.gbft.framework.data.Event.EventType;\nimport com.gbft.framework.utils.Config;\nimport com.gbft.framework.utils.ConfigObject;\nimport com.gbft.framework.utils.DataUtils;\nimport com.gbft.framework.utils.EntityMapUtils;\nimport com.gbft.framework.utils.Printer;\n\npublic class CoordinatorServer extends CoordinatorBase {\n    private String protocol;\n    private Map<String, String> configContent;\n\n    private Map<EventType, Integer> responseCounter;\n\n    private Benchmarker benchmarker;\n\n    public CoordinatorServer(String protocol, int port) {\n        super(port);\n\n        this.protocol = protocol;\n\n        responseCounter = new HashMap<>();\n        configContent = new HashMap<>();\n\n        try {\n            var frameworkConfig = Files.readString(Path.of(\"../config/config.framework.yaml\"));\n            var protocolPool = new ConfigObject(frameworkConfig, \"\").stringList(\"switching.protocol-pool\");\n\n            configContent.put(\"framework\", frameworkConfig);\n\n            for (var pname : protocolPool) {\n                var protocolConfig = Files.readString(Path.of(\"../config/config.\" + pname + \".yaml\"));\n                configContent.put(pname, protocolConfig);\n            }\n\n            initFromConfig(configContent, protocol);\n        } catch (IOException e) {\n            System.err.println(\"Error reading config files.\");\n            System.exit(1);\n        }\n\n        benchmarker = new Benchmarker();\n    }\n\n    public void run() {\n        System.out.println(\"Press Enter after all units are connected, to start the benchmark.\");\n        System.console().readLine();\n\n        System.out.println(\"Clients: \" + EntityMapUtils.getAllClients());\n        System.out.println(\"Nodes: \" + EntityMapUtils.getAllNodes());\n        System.out.print(\"Initializing units ...\");\n\n        var units = EntityMapUtils.getAllUnits();\n\n        var configData = DataUtils.createConfigData(configContent, protocol, EntityMapUtils.allUnitData());\n        var configEvent = DataUtils.createEvent(configData);\n\n        sendEvent(units, configEvent);\n\n        var unitCount = EntityMapUtils.unitCount();\n\n        waitResponse(EventType.READY, unitCount);\n\n        var initPluginsEvent = DataUtils.createEvent(EventType.PLUGIN_INIT);\n        sendEvent(units, initPluginsEvent);\n\n        waitResponse(EventType.READY, unitCount);\n\n        var initConnectionsEvent = DataUtils.createEvent(EventType.CONNECTION, SERVER);\n        sendEvent(units, initConnectionsEvent);\n\n        waitResponse(EventType.READY, unitCount);\n\n        System.out.println(\"\\rUnits initialized.       \");\n\n        var startEvent = DataUtils.createEvent(EventType.START);\n        sendEvent(units, startEvent);\n\n        benchmarker.start();\n        System.out.println(\"Benchmark started.\");\n\n        System.out.println(\"Available commands: \\\"stop\\\"\");\n        try (var scanner = new Scanner(System.in)) {\n            while (isRunning) {\n                System.out.print(\"$ \");\n\n                var command = System.console().readLine();\n                if (command.equals(\"stop\")) {\n                    isRunning = false;\n                } else if (command.startsWith(\"block\")) {\n                    var split = command.split(\" \");\n                    int target = Integer.parseInt(split[1]);\n                    var blockEvent = DataUtils.createEvent(EventType.BLOCK, target);\n                    sendEvent(units, blockEvent);\n                }\n            }\n        }\n\n        benchmarker.stop();\n\n        println(\"Stopping all entities.\");\n        var stopEvent = DataUtils.createEvent(EventType.STOP);\n        sendEvent(units, stopEvent);\n\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n        }\n\n        stop();\n    }\n\n    @Override\n    public void receiveEvent(Event event, Socket socket) {\n\n        var eventType = event.getEventType();\n        if (eventType == EventType.INIT) {\n            var unitData = event.getUnitData();\n            EntityMapUtils.addUnitData(unitData);\n            println(\"Unit \" + unitData.getUnit() + \" is connected.\");\n        } else if (eventType == EventType.BENCHMARK_REPORT) {\n            var report = Printer.convertToString(event.getReportData());\n            benchmarker.print(report);\n        }\n\n        synchronized (responseCounter) {\n            responseCounter.put(eventType, responseCounter.getOrDefault(eventType, 0) + 1);\n            responseCounter.notify();\n        }\n    }\n\n    private void waitResponse(EventType eventType, int expectedCount) {\n        synchronized (responseCounter) {\n            while (responseCounter.getOrDefault(eventType, 0) < expectedCount) {\n                try {\n                    responseCounter.wait();\n                } catch (InterruptedException e) {\n                }\n            }\n\n            responseCounter.put(eventType, 0);\n        }\n    }\n\n    private class Benchmarker {\n        private final String outputFile;\n        private Timer benchmarkTimer;\n        private final long benchmarkInterval;\n\n        public Benchmarker() {\n            benchmarkInterval = Config.integer(\"benchmark.benchmark-interval-ms\");\n\n            var directory = new File(\"benchmarks/\");\n            directory.mkdirs();\n            var lastBenchmarkId = Stream.of(directory.listFiles())\n                                        .map(file -> file.getName().split(\"-\")[0])\n                                        .filter(id -> StringUtils.isNumeric(id))\n                                        .sorted(Comparator.reverseOrder()).findFirst().orElse(\"0000\");\n\n            var num = Integer.parseInt(lastBenchmarkId) + 1;\n            var nextBenchmarkId = StringUtils.leftPad(num + \"\", 4).replace(' ', '0');\n            outputFile = \"benchmarks/\" + nextBenchmarkId + \"-\" + protocol + \".txt\";\n\n            benchmarkTimer = new Timer();\n\n            printTitle();\n        }\n\n        private void start() {\n            benchmarkTimer.schedule(new BenchmarkTask(), benchmarkInterval, benchmarkInterval);\n        }\n\n        private void stop() {\n            benchmarkTimer.cancel();\n        }\n\n        private void printTitle() {\n            var reqinterval = Config.integer(\"benchmark.request-interval-micros\") * 1000L;\n            var blockSize = Config.integer(\"benchmark.block-size\");\n            var f = Config.integer(\"general.f\");\n\n            var title = new StringBuilder();\n            title.append(\"== Benchmark Parameters: request-interval (initial)=\").append(Printer.timeFormat(reqinterval, true))\n                 .append(\", block-size=\").append(blockSize).append(\", nodes=\").append(EntityMapUtils.nodeCount())\n                 .append(\", f=\").append(f).append(\"\\n\");\n\n            print(title.toString());\n        }\n\n        private void print(String str) {\n            try {\n                Files.writeString(Path.of(outputFile), str,\n                        StandardOpenOption.CREATE, StandardOpenOption.WRITE, StandardOpenOption.APPEND);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private class BenchmarkTask extends TimerTask {\n\n        private int reportnum = 0;\n\n        @Override\n        public void run() {\n            if (isRunning) {\n                reportnum += 1;\n                var t = benchmarker.benchmarkInterval * reportnum;\n                benchmarker.print(\"-- Report #\" + reportnum + \" @ t=\" + Printer.timeFormat(t * 1000000L, true) + \" --\\n\");\n\n                var units = EntityMapUtils.getAllUnits();\n                var reportEvent = DataUtils.createEvent(EventType.BENCHMARK_REPORT);\n                sendEvent(units, reportEvent);\n            }\n\n        }\n    }\n\n    public static void main(String[] args) {\n        Options options = new Options();\n\n        var portOption = new Option(\"p\", \"port\", true, \"the coordination server port\");\n        var protocolOption = new Option(\"r\", \"protocol\", true, \"the benchmark protocol\");\n        portOption.setType(Number.class);\n        portOption.setRequired(true);\n        protocolOption.setRequired(true);\n\n        options.addOption(portOption);\n        options.addOption(protocolOption);\n\n        CommandLineParser parser = new DefaultParser();\n        try {\n            CommandLine cmd = parser.parse(options, args);\n            Number port = (Number) cmd.getParsedOptionValue(\"port\");\n            var protocol = cmd.getOptionValue(\"protocol\");\n\n            new CoordinatorServer(protocol, port.intValue()).run();\n        } catch (ParseException e) {\n            System.err.println(\"Command parsing error: \" + e.getMessage());\n            var formatter = new HelpFormatter();\n            formatter.printHelp(\"Usage:\", options);\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/coordination/CoordinatorServer.java b/code/src/com/gbft/framework/coordination/CoordinatorServer.java
--- a/code/src/com/gbft/framework/coordination/CoordinatorServer.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/coordination/CoordinatorServer.java	(date 1712692074659)
@@ -259,6 +259,8 @@
             CommandLine cmd = parser.parse(options, args);
             Number port = (Number) cmd.getParsedOptionValue("port");
             var protocol = cmd.getOptionValue("protocol");
+            //LogWrite t=new LogWrite();
+            //t.write(6,"protocol: "+protocol);
 
             new CoordinatorServer(protocol, port.intValue()).run();
         } catch (ParseException e) {
Index: code/src/com/gbft/framework/coordination/CoordinatorBase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.coordination;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketException;\nimport java.net.UnknownHostException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.lang3.tuple.Pair;\n\nimport com.gbft.framework.data.Event;\nimport com.gbft.framework.data.Event.EventType;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.gbft.framework.utils.AdvanceConfig;\nimport com.gbft.framework.utils.Config;\n\npublic abstract class CoordinatorBase {\n    protected static final int SERVER = -1;\n    private static SimpleDateFormat dateFormat = new SimpleDateFormat(\"HH:mm:ss.S \");\n\n    protected boolean isRunning;\n\n    private ServerSocket serverSocket;\n    protected Thread listenerThread;\n\n    protected Map<Integer, Pair<String, Integer>> unitAddressMap;\n\n    public CoordinatorBase(int port) {\n        isRunning = true;\n        unitAddressMap = new HashMap<>();\n\n        try {\n            serverSocket = new ServerSocket(port);\n            listenerThread = new Thread(() -> netListen());\n            listenerThread.start();\n        } catch (IOException e) {\n            System.err.println(\"Problem while creating socket.\");\n            isRunning = false;\n        }\n    }\n\n    protected void initFromConfig(Map<String, String> yamlData, String defaultProtocol) {\n        try {\n            Config.load(yamlData, defaultProtocol);\n            AdvanceConfig.load(yamlData.get(\"framework\"));\n        } catch (IOException e) {\n            System.err.println(\"Error loading config.\");\n            System.exit(1);\n        }\n\n        var unitConfig = Config.list(\"network.units\");\n        for (var i = 0; i < unitConfig.size(); i++) {\n            var address = unitConfig.get(i).split(\":\");\n            unitAddressMap.put(i, Pair.of(address[0], Integer.parseInt(address[1])));\n        }\n\n        StateMachine.init();\n    }\n\n    public void sendEvent(List<Integer> units, Event event) {\n        for (var unit : units) {\n            sendEvent(unit, event);\n        }\n    }\n\n    public void sendEvent(int unit, Event event) {\n        var address = unitAddressMap.get(unit);\n\n        try {\n            var socket = new Socket(address.getLeft(), address.getRight());\n            new Thread(() -> netSend(socket, event)).start();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (ConnectException e) {\n            System.err.println(\"Could not connect to \" + address);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected abstract void receiveEvent(Event event, Socket socket);\n\n    protected void netSend(Socket socket, Event event) {\n        DataOutputStream out;\n        var is_connection = event.getEventType() == EventType.CONNECTION;\n        try {\n            out = new DataOutputStream(socket.getOutputStream());\n            var bytes = event.toByteArray();\n\n            out.writeInt(bytes.length);\n            out.write(bytes);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (!is_connection) {\n                    socket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    protected void netReceive(Socket socket) {\n        DataInputStream in;\n        boolean is_connection = false;\n        try {\n            in = new DataInputStream(socket.getInputStream());\n\n            var messageLen = in.readInt();\n            var message = in.readNBytes(messageLen);\n\n            var event = Event.parseFrom(message);\n            is_connection = event.getEventType() == EventType.CONNECTION;\n\n            receiveEvent(event, socket);\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (!is_connection) {\n                    socket.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void netListen() {\n        while (isRunning) {\n            try {\n                if (serverSocket.isClosed()) {\n                    isRunning = false;\n                    break;\n                }\n\n                var socket = serverSocket.accept();\n                // TODO: Use Virtual Threads\n                new Thread(() -> netReceive(socket)).start();\n            } catch (SocketException e) {\n                isRunning = false;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        println(\"Net listener stopped.\");\n    }\n\n    protected void stop() {\n        isRunning = false;\n        listenerThread.interrupt();\n        try {\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    protected void println(String str) {\n        var date = dateFormat.format(new Date(System.currentTimeMillis()));\n        System.out.println(date + \" \" + str);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/coordination/CoordinatorBase.java b/code/src/com/gbft/framework/coordination/CoordinatorBase.java
--- a/code/src/com/gbft/framework/coordination/CoordinatorBase.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/coordination/CoordinatorBase.java	(date 1712530281331)
@@ -32,10 +32,14 @@
     protected Thread listenerThread;
 
     protected Map<Integer, Pair<String, Integer>> unitAddressMap;
+    public LogWrite l =new LogWrite();
+    public int s_port;
 
     public CoordinatorBase(int port) {
         isRunning = true;
         unitAddressMap = new HashMap<>();
+        l.Intialize(port);
+        this.s_port=port;
 
         try {
             serverSocket = new ServerSocket(port);
@@ -61,6 +65,9 @@
             var address = unitConfig.get(i).split(":");
             unitAddressMap.put(i, Pair.of(address[0], Integer.parseInt(address[1])));
         }
+        System.out.println("cord base 64 new: " + unitAddressMap);
+        String abc = "cord base 64 new : " + unitAddressMap;
+        l.PortWrite(s_port,abc);
 
         StateMachine.init();
     }
Index: code/pom.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>gbft</groupId>\n  <artifactId>gbft</artifactId>\n  <version>0.0.1</version>\n  <name>GBFT</name>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <plugins>\n      <plugin>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.8.1</version>\n        <configuration>\n          <release>20</release>\n            <compilerArgs>\n              <arg>--enable-preview</arg>\n            </compilerArgs>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n  <dependencies>\n    <!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->\n    <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-lang3</artifactId>\n      <version>3.12.0</version>\n    </dependency>\n    <!-- https://mvnrepository.com/artifact/commons-cli/commons-cli -->\n    <dependency>\n      <groupId>commons-cli</groupId>\n      <artifactId>commons-cli</artifactId>\n      <version>1.5.0</version>\n    </dependency>\n    <!-- https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java -->\n    <dependency>\n      <groupId>com.google.protobuf</groupId>\n      <artifactId>protobuf-java</artifactId>\n      <version>3.21.12</version>\n    </dependency>\n    <!-- https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java-util -->\n    <dependency>\n      <groupId>com.google.protobuf</groupId>\n      <artifactId>protobuf-java-util</artifactId>\n      <version>3.21.12</version>\n    </dependency>\n    <!-- https://mvnrepository.com/artifact/com.amihaiemil.web/eo-yaml -->\n    <dependency>\n      <groupId>com.amihaiemil.web</groupId>\n      <artifactId>eo-yaml</artifactId>\n      <version>7.0.1</version>\n    </dependency>\n    <dependency>\n      <groupId>io.grpc</groupId>\n      <artifactId>grpc-netty-shaded</artifactId>\n      <version>1.54.1</version>\n      <scope>runtime</scope>\n    </dependency>\n    <dependency>\n      <groupId>io.grpc</groupId>\n      <artifactId>grpc-protobuf</artifactId>\n      <version>1.54.1</version>\n    </dependency>\n    <dependency>\n      <groupId>io.grpc</groupId>\n      <artifactId>grpc-stub</artifactId>\n      <version>1.54.1</version>\n    </dependency>\n    <dependency> <!-- necessary for Java 9+ -->\n      <groupId>org.apache.tomcat</groupId>\n      <artifactId>annotations-api</artifactId>\n      <version>6.0.53</version>\n      <scope>provided</scope>\n    </dependency>\n  </dependencies>\n</project>\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/pom.xml b/code/pom.xml
--- a/code/pom.xml	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/pom.xml	(date 1711217731534)
@@ -11,7 +11,7 @@
         <artifactId>maven-compiler-plugin</artifactId>
         <version>3.8.1</version>
         <configuration>
-          <release>20</release>
+          <release>21</release>
             <compilerArgs>
               <arg>--enable-preview</arg>
             </compilerArgs>
Index: code/src/com/gbft/framework/core/DynamicClient.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.core;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.atomic.LongAdder;\nimport java.util.concurrent.locks.LockSupport;\nimport java.util.stream.IntStream;\n\nimport com.gbft.framework.coordination.CoordinatorUnit;\nimport com.gbft.framework.data.RequestData;\n\npublic class DynamicClient extends Client {\n\n    public Map<Long, Long> intervals;\n    public Long startTime;\n    public Long expected;\n    private final int maxactive;\n\n    ConcurrentLinkedQueue<Long> timings;\n    private LongAdder total;\n    private static int window = 200;\n\n    public DynamicClient(int id, CoordinatorUnit coordinator) {\n        super(id, coordinator);\n        intervals = new ConcurrentHashMap<>();\n        maxactive = pipelinePlugin.getMaxActiveSequences();\n\n        timings = new ConcurrentLinkedQueue<>();\n        IntStream.range(0, window).forEach(i -> timings.add(intervalns));\n\n        total = new LongAdder();\n        total.add(intervalns * window);\n    }\n\n    @Override\n    public void execute(long seqnum) {\n        super.execute(seqnum);\n\n        var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);\n\n        var tally = checkpoint.getMessageTally();\n        var viewnum = tally.getMaxQuorum(seqnum);\n        var replies = tally.getQuorumReplies(seqnum, viewnum);\n\n        if (viewnum > currentViewNum) {\n            currentViewNum = viewnum;\n        }\n\n        if (replies != null) {\n            updateInterval(replies.keySet(), seqnum);\n        }\n    }\n\n    public void updateInterval(Set<Long> reqnums, long seqnum) {\n        var now = System.nanoTime();\n        var diff = now - expected;\n        var next = (diff + intervalns) / (blockSize + 1); // 2; //(diff + blockSize * intervalns) / (blockSize * 2);\n\n        var out = timings.remove();\n        timings.add(next);\n        total.add(next - out);\n        expected = now + blockSize * intervals.get(seqnum + 1);\n    }\n\n    @Override\n    protected RequestGenerator createRequestGenerator() {\n        return new DynamicRequestGenerator();\n    }\n\n    protected class DynamicRequestGenerator extends RequestGenerator {\n        @Override\n        public void init() {\n            threads.add(new Thread(new DynamicRequestGeneratorRunner()));\n        }\n\n        protected class DynamicRequestGeneratorRunner implements Runnable {\n            @Override\n            public void run() {\n\n                startTime = System.nanoTime();\n                expected = startTime + blockSize * maxactive * intervalns;\n\n                while (running) {\n                    var next = System.nanoTime() + intervalns;\n\n                    var request = dataset.createRequest(nextRequestNum);\n                    nextRequestNum += 1;\n\n                    sendRequest(request);\n\n                    while (System.nanoTime() < next) {\n                        LockSupport.parkNanos(intervalns / 3);\n                    }\n                }\n            }\n        }\n\n        @Override\n        protected void sendRequest(RequestData request) {\n            super.sendRequest(request);\n            var seqnum = nextRequestNum / blockSize;\n            if (!intervals.containsKey(seqnum)) {\n                intervals.put(seqnum, total.longValue() / window);\n            }\n            intervalns = intervals.get(seqnum);\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/core/DynamicClient.java b/code/src/com/gbft/framework/core/DynamicClient.java
--- a/code/src/com/gbft/framework/core/DynamicClient.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/core/DynamicClient.java	(date 1713896245527)
@@ -24,6 +24,7 @@
 
     public DynamicClient(int id, CoordinatorUnit coordinator) {
         super(id, coordinator);
+        l.write(id,"client called");
         intervals = new ConcurrentHashMap<>();
         maxactive = pipelinePlugin.getMaxActiveSequences();
 
@@ -36,6 +37,7 @@
 
     @Override
     public void execute(long seqnum) {
+        l.write(id,"dc: "+ Long.toString(seqnum));
         super.execute(seqnum);
 
         var checkpoint = checkpointManager.getCheckpointForSeq(seqnum);
@@ -84,7 +86,7 @@
 
                 while (running) {
                     var next = System.nanoTime() + intervalns;
-
+                    l.write(id,"\ndynamic request_num: "+nextRequestNum);
                     var request = dataset.createRequest(nextRequestNum);
                     nextRequestNum += 1;
 
Index: code/src/com/gbft/framework/coordination/CoordinatorUnit.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.coordination;\n\nimport java.io.IOException;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.commons.lang3.tuple.Pair;\n\nimport com.gbft.framework.core.Client;\nimport com.gbft.framework.core.DynamicClient;\nimport com.gbft.framework.core.Entity;\nimport com.gbft.framework.core.Node;\nimport com.gbft.framework.data.Event;\nimport com.gbft.framework.data.FaultData;\nimport com.gbft.framework.data.Event.EventType;\nimport com.gbft.framework.data.MessageData;\nimport com.gbft.framework.data.ReportData;\nimport com.gbft.framework.data.ReportData.ReportItem;\nimport com.gbft.framework.data.UnitData;\nimport com.gbft.framework.plugins.InitializablePluginInterface;\nimport com.gbft.framework.plugins.PluginManager;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.gbft.framework.utils.BenchmarkManager;\nimport com.gbft.framework.utils.Config;\nimport com.gbft.framework.utils.DataUtils;\nimport com.gbft.framework.utils.EntityMapUtils;\nimport com.gbft.framework.utils.Printer;\nimport com.gbft.framework.utils.RandomDataStream;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.Message;\n\npublic class CoordinatorUnit extends CoordinatorBase {\n\n    public static int unit_id;\n\n    private int myUnit;\n\n    private Map<Integer, Entity> entities;\n    private Map<Integer, Connection> connections;\n    private AtomicInteger connected_units;\n    private LinkedBlockingQueue<Event> inQueueClient = new LinkedBlockingQueue<>();\n    private LinkedBlockingQueue<Event> inQueueReplica = new LinkedBlockingQueue<>();\n    private Thread receiveFromInQueueClient;\n    private Thread receiveFromInQueueReplica;\n    public final long MESSAGE_WAIT_TIME = 100;\n    protected BenchmarkManager benchmarkManager;\n\n    public String defaultProtocol;\n    public int port;\n\n    public CoordinatorUnit(int port, int unit, int nodeCount, int clientCount, String coordinationServerAddress) {\n        super(port);\n        this.port = port;\n\n        myUnit = unit;\n        unit_id = unit;\n\n        entities = new HashMap<>();\n        connections = new ConcurrentHashMap<>();\n        connected_units = new AtomicInteger(0);\n\n        var split = coordinationServerAddress.split(\":\");\n        unitAddressMap.put(SERVER, Pair.of(split[0], Integer.parseInt(split[1])));\n\n        var unitData = DataUtils.createUnitData(unit, nodeCount, clientCount);\n        var initEvent = DataUtils.createEvent(unitData);\n        sendEvent(SERVER, initEvent);\n    }\n\n    @Override\n    public void receiveEvent(Event event, Socket socket) {\n        var coordinationType = event.getEventType();\n        if (coordinationType == EventType.CONFIG) {\n            initFromConfig(event.getConfigData().getDataMap(), event.getConfigData().getDefaultProtocol(), event.getConfigData().getUnitsList());\n            defaultProtocol = event.getConfigData().getDefaultProtocol();\n            Config.setCurrentProtocol(defaultProtocol);\n\n            var clientType = Config.string(\"benchmark.client\");\n            EntityMapUtils.getUnitClients(myUnit).forEach(id -> entities.put(id, genClient(clientType, id)));\n            EntityMapUtils.getUnitNodes(myUnit).forEach(id -> entities.put(id, new Node(id, this)));\n\n            // PluginManager.getRolePlugin(entities.get(0)).debugRoleMap();\n\n            benchmarkManager = new BenchmarkManager(null);\n\n            for (var unit : EntityMapUtils.getAllUnits()) {\n                if (unit != myUnit) {\n                    var connection = new Connection(this, myUnit, unit, inQueueClient, inQueueReplica, benchmarkManager);\n                    connections.put(unit, connection);\n                }\n            }\n\n            var allReadyEvent = DataUtils.createEvent(EventType.READY);\n            sendEvent(SERVER, allReadyEvent);\n\n            println(\"Unit configured.\");\n        } else if (coordinationType == EventType.PLUGIN_INIT) {\n            var data = event.getPluginData();\n            var targets = data.getTargetsCount() == 0 ? entities.keySet() : data.getTargetsList();\n            for (var id : targets) {\n                var entity = entities.get(id);\n                var plugins = entity.getMessagePlugins();\n                for (var plugin : plugins) {\n                    if (plugin instanceof InitializablePluginInterface initPlugin) {\n                        initPlugin.handleInitEvent(event.getPluginData());\n                    }\n                }\n            }\n            var finished = true;\n            for (var entity : entities.values()) {\n                var plugins = entity.getMessagePlugins();\n                for (var plugin : plugins) {\n                    if (plugin instanceof InitializablePluginInterface initPlugin) {\n                        finished = finished && initPlugin.isInitialized();\n                    }\n                }\n\n            }\n            if (finished) {\n                var readyEvent = DataUtils.createEvent(EventType.READY);\n                superSendEvent(SERVER, readyEvent);\n            }\n        } else if (coordinationType == EventType.CONNECTION) {\n            if (event.getTarget() == SERVER) {\n                println(\"Received connection event from server.\");\n                for (var connection : connections.values()) {\n                    if (connection.createSocket()) {\n                        connected_units.incrementAndGet();\n                    }\n                }\n\n                while (connected_units.get() < EntityMapUtils.unitCount() - 1)\n                    ;\n\n                connections.values().forEach(connection -> connection.startSenderReceiver());\n                receiveFromInQueueClient = new Thread(new ReceiverPoller(inQueueClient));\n                receiveFromInQueueClient.start();\n                receiveFromInQueueReplica = new Thread(new ReceiverPoller(inQueueReplica));\n                receiveFromInQueueReplica.start();\n\n                var allReadyEvent = DataUtils.createEvent(EventType.READY);\n                sendEvent(SERVER, allReadyEvent);\n                println(\"Connection initialized.\");\n            } else {\n                println(\"Received connection event from unit \" + event.getTarget() + \".\");\n                connections.get(event.getTarget()).createSocket(socket);\n                connected_units.incrementAndGet();\n            }\n        } else if (coordinationType == EventType.START) {\n            for (var entity : entities.values()) {\n                entity.start();\n            }\n            benchmarkManager.start();\n\n            println(\"Benchmark started.\");\n        } else if (coordinationType == EventType.BENCHMARK_REPORT) {\n\n            println(\"Sending benchmark results to server.\");\n\n            var reportData = ReportData.newBuilder();\n            for (var id : entities.keySet()) {\n                var map = entities.get(id).reportBenchmark();\n                var item = ReportItem.newBuilder().putAllItemData(map).build();\n                var name = (entities.get(id).isClient() ? \"Client \" : \"Node \") + id;\n                reportData.putReportData(name, item);\n            }\n            // var map = reportBenchmark();\n            // var item = ReportItem.newBuilder().putAllItemData(map).build();\n            // reportData.putReportData(\"CoordinatorUnit \" + myUnit, item);\n\n            var reportEvent = DataUtils.createEvent(reportData.build());\n\n            sendEvent(SERVER, reportEvent);\n\n            println(Printer.convertToString(reportEvent.getReportData()));\n        } else if (coordinationType == EventType.STOP) {\n            for (var entity : entities.values()) {\n                entity.stop();\n            }\n            connections.values().forEach(connection -> connection.closeConnection());\n\n            Printer.flush();\n\n            println(\"Unit execution stopped.\");\n            stop();\n            receiveFromInQueueClient.interrupt();\n            receiveFromInQueueReplica.interrupt();\n        } else if (event.getEventType() == EventType.MESSAGE) {\n            var messages = event.getMessageBlock().getMessageDataList();\n\n            // TODO: More parallel.\n            for (var message : messages) {\n                var targets = message.getTargetsList();\n                for (var target : targets) {\n                    if (target == message.getSource() || EntityMapUtils.getUnit(target) != myUnit) {\n                        continue;\n                    }\n\n                    // TODO: Use Virtual Thread.\n\n\t\t\t\t\t// in-dark attack\n\t\t\t\t\tif (message.getFault().getBlockedTargetsList().contains(target)) continue;\n\t\t\t\t\t// timeout attack\n\t\t\t\t\tvar delay = 0L;\n\t\t\t\t\tif (message.getFault().getDelayedTargetsList().contains(target))\n\t\t\t\t\t\tdelay = message.getFault().getDelay();\n\t\t\t\t\tfinal long _delay = delay;\n\t\t\t\t\t// execute\n\t\t\t\t\tnew Thread(() -> {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tif (_delay > 0L) Thread.sleep(_delay);\n\t\t\t\t\t\t\tentities.get(target).handleMessage(message);\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t}\n\t\t\t\t\t}).start();\n                }\n            }\n        }\n    }\n\n    protected class ReceiverPoller implements Runnable {\n\n        private LinkedBlockingQueue<Event> inQueue;\n\n        protected ReceiverPoller(LinkedBlockingQueue<Event> inQueue) {\n            this.inQueue = inQueue;\n        }\n\n        @Override\n        public void run() {\n            while (isRunning) {\n                try {\n                    var event = this.inQueue.poll(MESSAGE_WAIT_TIME, TimeUnit.MILLISECONDS);\n\n                    if (event != null) {\n                        if (event.getEventType() == EventType.MESSAGE) {\n                            var messages = event.getMessageBlock().getMessageDataList();\n\n                            for (var message : messages) {\n                                var targets = message.getTargetsList();\n                                for (var target : targets) {\n                                    if (target == message.getSource() || EntityMapUtils.getUnit(target) != myUnit) {\n                                        continue;\n                                    }\n\n\t\t\t\t\t\t\t\t\t// in-dark attack\n\t\t\t\t\t\t\t\t\tif (message.getFault().getBlockedTargetsList().contains(target)) continue;\n\t\t\t\t\t\t\t\t\t// timeout attack\n\t\t\t\t\t\t\t\t\tvar delay = 0L;\n\t\t\t\t\t\t\t\t\tif (message.getFault().getDelayedTargetsList().contains(target))\n\t\t\t\t\t\t\t\t\t\tdelay = message.getFault().getDelay();\n\t\t\t\t\t\t\t\t\tfinal long _delay = delay;\n\t\t\t\t\t\t\t\t\t// execute\n\t\t\t\t\t\t\t\t\tnew Thread(() -> {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tif (_delay > 0L) Thread.sleep(_delay);\n\t\t\t\t\t\t\t\t\t\t\tentities.get(target).handleMessage(message);\n\t\t\t\t\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}).start();\n                                }\n                            }\n                        }\n\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public void superSendEvent(int unit, Event event) {\n        if (unit == myUnit) {\n            receiveEvent(event, null);\n        } else {\n            super.sendEvent(unit, event);\n        }\n    }\n\n    @Override\n    public void sendEvent(int unit, Event event) {\n        if (unit == myUnit) {\n            receiveEvent(event, null);\n        } else {\n            if (unit != SERVER) {\n                benchmarkManager.add(BenchmarkManager.COORDINATOR_UNIT_SEND, 0, System.nanoTime());\n            }\n            if (connections.containsKey(unit)) {\n                connections.get(unit).send(event);\n            } else {\n                super.sendEvent(unit, event);\n            }\n        }\n    }\n\n    @Override\n    public void sendEvent(List<Integer> units, Event event) {\n        for (var unit : units) {\n            sendEvent(unit, event);\n        }\n    }\n\n    public void sendMessages(List<MessageData> messages, int sender) {\n        var units = messages.parallelStream().flatMap(message -> message.getTargetsList().stream())\n                .map(target -> EntityMapUtils.getUnit(target))\n                .distinct()\n                .toList();\n\n        List<MessageData> transformedMessages = new ArrayList<>();\n\n        Entity senderEntity = this.entities.get(sender);\n        // fault implementation\n        if (senderEntity.isPrimary()) {\n            for (var message : messages) {\n\t\t\t\tvar faultDataBuilder = FaultData.newBuilder()\n\t\t\t\t\t.addAllDelayedTargets(senderEntity.getTimeoutFault().getAffectedEntities())\n\t\t\t\t\t.setDelay(senderEntity.getTimeoutFault().getDelay());\n\n                if (senderEntity.getInDarkFault().getApply()) {\n                    faultDataBuilder = faultDataBuilder.addAllBlockedTargets(senderEntity.getInDarkFault().getAffectedEntities());\n                }\n                transformedMessages.add(message.toBuilder().setFault(faultDataBuilder).build());\n            }\n        } else {\n            transformedMessages = messages;\n        }\n\n        List<MessageData> sizeTransformedMessages = new ArrayList<>();\n        for (var message : transformedMessages) {\n            if (message.getMessageType() == StateMachine.REPLY) {\n                var requests = message.getRequestsList();\n                var m = message.toBuilder().clearRequests();\n                for (var request : requests) {\n                    try {\n                        m.addRequests(request.toBuilder().clearRequestDummy().setRequestDummy(ByteString.readFrom(new RandomDataStream(request.getReplySize()))));\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n                sizeTransformedMessages.add(m.build());\n            } else {\n                sizeTransformedMessages.add(message);\n            }\n        }\n\n        var event = DataUtils.createEvent(sizeTransformedMessages);\n        sendEvent(units, event);\n    }\n\n    public void initFromConfig(Map<String, String> configContent, String defaultProtocol, List<UnitData> unitData) {\n        initFromConfig(configContent, defaultProtocol);\n\n        Printer.init();\n        PluginManager.initDefaultPlugins();\n        unitData.forEach(item -> EntityMapUtils.addUnitData(item));\n    }\n\n    private Client genClient(String type, int id) {\n        return type.equals(\"basic\") ? new Client(id, this) : new DynamicClient(id, this);\n    }\n\n    protected int reportnum = 0;\n\n    public Map<String, String> reportBenchmark() {\n        var benchmark = benchmarkManager.getBenchmarkById(reportnum);\n\n        var report = new HashMap<String, String>();\n        report.put(\"connection-send\", \"count: \" + benchmark.count(BenchmarkManager.CONNECTION_SEND));\n        report.put(\"connection-begin-send\", \"count: \" + benchmark.count(BenchmarkManager.CONNECTION_BEGIN_SEND));\n        report.put(\"sender-thread-write\", \"count: \" + benchmark.count(BenchmarkManager.SENDER_THREAD_WRITE));\n        report.put(\"receiver-thread-inqueue-client\",\n                \"count: \" + benchmark.count(BenchmarkManager.RECEIVER_THREAD_INQUEUE_CLIENT));\n        report.put(\"receiver-thread-inqueue-replica\",\n                \"count: \" + benchmark.count(BenchmarkManager.RECEIVER_THREAD_INQUEUE_REPLICA));\n        report.put(\"coordinator-unit-sendevent\", \"count: \" + benchmark.count(BenchmarkManager.COORDINATOR_UNIT_SEND));\n\n        report.put(\"active threads\", \"count: \" + Thread.activeCount());\n\n        reportnum += 1;\n        return report;\n    }\n\n    public static void main(String[] args) {\n        Options options = new Options();\n        var unitOption = new Option(\"u\", \"unit\", true, \"the coordination unit number\");\n        var portOption = new Option(\"p\", \"port\", true, \"the coordination unit port\");\n        var nodesOption = new Option(\"n\", \"nodes\", true, \"the number of nodes\");\n        var clientsOption = new Option(\"c\", \"clients\", true, \"the number of clients\");\n        var serverOption = new Option(\"s\", \"server\", true, \"the coordination server address\");\n        unitOption.setType(Number.class);\n        unitOption.setRequired(true);\n        portOption.setType(Number.class);\n        portOption.setRequired(true);\n        nodesOption.setType(Number.class);\n        clientsOption.setType(Number.class);\n        serverOption.setRequired(true);\n\n        options.addOption(unitOption);\n        options.addOption(portOption);\n        options.addOption(nodesOption);\n        options.addOption(clientsOption);\n        options.addOption(serverOption);\n\n        CommandLineParser parser = new DefaultParser();\n        try {\n            CommandLine cmd = parser.parse(options, args);\n            Number unit = (Number) cmd.getParsedOptionValue(\"unit\");\n            Number port = (Number) cmd.getParsedOptionValue(\"port\");\n            var serverAddress = cmd.getOptionValue(\"server\");\n\n            int nodeCount = 0, clientCount = 0;\n            if (cmd.hasOption(\"nodes\")) {\n                var nodeOp = (Number) cmd.getParsedOptionValue(\"nodes\");\n                if (nodeOp.intValue() > 0) {\n                    nodeCount = nodeOp.intValue();\n                }\n            }\n            if (cmd.hasOption(\"clients\")) {\n                var clientOp = (Number) cmd.getParsedOptionValue(\"clients\");\n                if (clientOp.intValue() > 0) {\n                    clientCount = clientOp.intValue();\n                }\n            }\n\n            new CoordinatorUnit(port.intValue(), unit.intValue(), nodeCount, clientCount, serverAddress);\n        } catch (ParseException e) {\n            System.err.println(\"Command parsing error: \" + e.getMessage());\n            var formatter = new HelpFormatter();\n            formatter.printHelp(\"Usage:\", options);\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/coordination/CoordinatorUnit.java b/code/src/com/gbft/framework/coordination/CoordinatorUnit.java
--- a/code/src/com/gbft/framework/coordination/CoordinatorUnit.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/coordination/CoordinatorUnit.java	(date 1713897926261)
@@ -85,12 +85,14 @@
     public void receiveEvent(Event event, Socket socket) {
         var coordinationType = event.getEventType();
         if (coordinationType == EventType.CONFIG) {
+            l.PortWrite(port,"config id:");
             initFromConfig(event.getConfigData().getDataMap(), event.getConfigData().getDefaultProtocol(), event.getConfigData().getUnitsList());
             defaultProtocol = event.getConfigData().getDefaultProtocol();
             Config.setCurrentProtocol(defaultProtocol);
 
             var clientType = Config.string("benchmark.client");
             EntityMapUtils.getUnitClients(myUnit).forEach(id -> entities.put(id, genClient(clientType, id)));
+            //entities.put(port%10-1, genClient(clientType, port%10-1));
             EntityMapUtils.getUnitNodes(myUnit).forEach(id -> entities.put(id, new Node(id, this)));
 
             // PluginManager.getRolePlugin(entities.get(0)).debugRoleMap();
@@ -108,7 +110,8 @@
             sendEvent(SERVER, allReadyEvent);
 
             println("Unit configured.");
-        } else if (coordinationType == EventType.PLUGIN_INIT) {
+        }
+        else if (coordinationType == EventType.PLUGIN_INIT) {
             var data = event.getPluginData();
             var targets = data.getTargetsCount() == 0 ? entities.keySet() : data.getTargetsList();
             for (var id : targets) {
@@ -134,7 +137,8 @@
                 var readyEvent = DataUtils.createEvent(EventType.READY);
                 superSendEvent(SERVER, readyEvent);
             }
-        } else if (coordinationType == EventType.CONNECTION) {
+        }
+        else if (coordinationType == EventType.CONNECTION) {
             if (event.getTarget() == SERVER) {
                 println("Received connection event from server.");
                 for (var connection : connections.values()) {
@@ -160,14 +164,16 @@
                 connections.get(event.getTarget()).createSocket(socket);
                 connected_units.incrementAndGet();
             }
-        } else if (coordinationType == EventType.START) {
+        }
+        else if (coordinationType == EventType.START) {
             for (var entity : entities.values()) {
                 entity.start();
             }
             benchmarkManager.start();
 
             println("Benchmark started.");
-        } else if (coordinationType == EventType.BENCHMARK_REPORT) {
+        }
+        else if (coordinationType == EventType.BENCHMARK_REPORT) {
 
             println("Sending benchmark results to server.");
 
@@ -187,7 +193,8 @@
             sendEvent(SERVER, reportEvent);
 
             println(Printer.convertToString(reportEvent.getReportData()));
-        } else if (coordinationType == EventType.STOP) {
+        }
+        else if (coordinationType == EventType.STOP) {
             for (var entity : entities.values()) {
                 entity.stop();
             }
@@ -199,8 +206,10 @@
             stop();
             receiveFromInQueueClient.interrupt();
             receiveFromInQueueReplica.interrupt();
-        } else if (event.getEventType() == EventType.MESSAGE) {
+        }
+        else if (event.getEventType() == EventType.MESSAGE) {
             var messages = event.getMessageBlock().getMessageDataList();
+            //l.PortWrite(port,"-> "+messages.toString());
 
             // TODO: More parallel.
             for (var message : messages) {
@@ -318,6 +327,7 @@
     }
 
     public void sendMessages(List<MessageData> messages, int sender) {
+        l.PortWrite(port,"messages: "+messages.toString());
         var units = messages.parallelStream().flatMap(message -> message.getTargetsList().stream())
                 .map(target -> EntityMapUtils.getUnit(target))
                 .distinct()
@@ -373,6 +383,7 @@
     }
 
     private Client genClient(String type, int id) {
+        l.PortWrite(port,"genclient id:"+id+" type: "+type);
         return type.equals("basic") ? new Client(id, this) : new DynamicClient(id, this);
     }
 
Index: data/build-proto.sh
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># The following command requires protoc-gen-grpc-java plugin to be installed\nmkdir -p target/java && protoc --plugin=protoc-gen-grpc-java=/usr/local/bin/protoc-gen-grpc-java \\\n    --grpc-java_out=target/java --proto_path=include/ --proto_path=proto/ proto/gbft.proto\nprotoc --proto_path=include/ --proto_path=proto/ --java_out=target/java proto/gbft.proto\n# The following command requires grpcio-tools installed for python\npython3 -m grpc_tools.protoc -I proto/ --python_out=../code/learning/ --grpc_python_out=../code/learning/ gbft.proto
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/data/build-proto.sh b/data/build-proto.sh
--- a/data/build-proto.sh	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/data/build-proto.sh	(date 1713840107553)
@@ -1,6 +1,6 @@
 # The following command requires protoc-gen-grpc-java plugin to be installed
-mkdir -p target/java && protoc --plugin=protoc-gen-grpc-java=/usr/local/bin/protoc-gen-grpc-java \
+mkdir -p /Users/sai/Desktop/Project_P/BFTBrain/data/target/java && protoc --plugin=protoc-gen-grpc-java=/usr/local/bin/protoc-gen-grpc-java \
     --grpc-java_out=target/java --proto_path=include/ --proto_path=proto/ proto/gbft.proto
-protoc --proto_path=include/ --proto_path=proto/ --java_out=target/java proto/gbft.proto
+protoc --proto_path=include/ --proto_path=proto/ --java_out=/Users/sai/Desktop/Project_P/BFTBrain/data/target/java proto/gbft.proto
 # The following command requires grpcio-tools installed for python
-python3 -m grpc_tools.protoc -I proto/ --python_out=../code/learning/ --grpc_python_out=../code/learning/ gbft.proto
\ No newline at end of file
+python3 -m grpc_tools.protoc -I proto/ --python_out=/Users/sai/Desktop/Project_P/BFTBrain/code/learning/ --grpc_python_out=/Users/sai/Desktop/Project_P/BFTBrain/code/learning/ gbft.proto
\ No newline at end of file
Index: code/src/com/gbft/framework/core/Dataset.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.core;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport com.gbft.framework.data.RequestData;\nimport com.gbft.framework.utils.Config;\nimport com.gbft.framework.utils.DataUtils;\n\npublic class Dataset {\n\n    protected Map<Integer, AtomicInteger> records;\n\n    public static final int DEFAULT_VALUE = 1000;\n    public static final int RECORD_COUNT = Config.integer(\"workload.dataset-size\");\n\n    public Dataset() {\n        records = DataUtils.concurrentMapWithDefaults(RECORD_COUNT, x -> new AtomicInteger(DEFAULT_VALUE));\n    }\n\n    // use this for copying service state\n    public Dataset(Dataset dataset) {\n        records = new TreeMap<>();\n        for (var entry : dataset.records.entrySet()) {\n            this.records.put(entry.getKey(), new AtomicInteger(entry.getValue().get()));\n        }\n    }\n\n    public void setRecords(Map<Integer, Integer> records) {\n        this.records.clear();\n        for (var entry : records.entrySet()) {\n            this.records.put(entry.getKey(), new AtomicInteger(entry.getValue()));\n        }\n    }\n    \n    public Map<Integer, AtomicInteger> getRecords() {\n        return records;\n    }\n\n    public int execute(RequestData request) {\n        var op = request.getOperation();\n        var record = request.getRecord();\n\n        // dummy computation\n        if (request.getComputeFactor() > 0) {\n            var dummy_counter = 0;\n            var random = new Random();\n            for (int i = 0; i < request.getComputeFactor(); i ++) {\n                dummy_counter += random.nextInt();\n            }\n            try {\n                OutputStream.nullOutputStream().write(dummy_counter);\n            } catch (IOException e) {}\n        }\n\n        int value = 0;\n\n        switch (op) {\n        case ADD:\n            value = records.get(record).addAndGet(request.getValue());\n            break;\n        case SUB:\n            value = records.get(record).addAndGet(-request.getValue());\n            break;\n        case INC:\n            value = records.get(record).incrementAndGet();\n            break;\n        case DEC:\n            value = records.get(record).decrementAndGet();\n            break;\n        case READ_ONLY:\n            value = records.get(record).get();\n        default:\n            value = records.get(record).get();\n        }\n\n        return value;\n    }\n\n    public void update(RequestData request, int value) {\n        var record = request.getRecord();\n        records.get(record).set(value);\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/core/Dataset.java b/code/src/com/gbft/framework/core/Dataset.java
--- a/code/src/com/gbft/framework/core/Dataset.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/core/Dataset.java	(date 1713890716670)
@@ -10,8 +10,10 @@
 import com.gbft.framework.data.RequestData;
 import com.gbft.framework.utils.Config;
 import com.gbft.framework.utils.DataUtils;
+import com.gbft.framework.coordination.LogWrite;
 
 public class Dataset {
+    public LogWrite l = new LogWrite();
 
     protected Map<Integer, AtomicInteger> records;
 
@@ -44,6 +46,7 @@
     public int execute(RequestData request) {
         var op = request.getOperation();
         var record = request.getRecord();
+        //l.write(4,"\ndataset class | execute recordnum: "+Integer.toString(record));
 
         // dummy computation
         if (request.getComputeFactor() > 0) {
@@ -84,6 +87,9 @@
     public void update(RequestData request, int value) {
         var record = request.getRecord();
         records.get(record).set(value);
+
+        l.write(4,"\n { dataset class | update function \n record: "+record+"" +
+                "\nrecord_value: "+records.get(record)+"}");
     }
 
 }
Index: code/learning/gbft_pb2.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># -*- coding: utf-8 -*-\n# Generated by the protocol buffer compiler.  DO NOT EDIT!\n# source: gbft.proto\n\"\"\"Generated protocol buffer code.\"\"\"\nfrom google.protobuf import descriptor as _descriptor\nfrom google.protobuf import descriptor_pool as _descriptor_pool\nfrom google.protobuf import symbol_database as _symbol_database\nfrom google.protobuf.internal import builder as _builder\n# @@protoc_insertion_point(imports)\n\n_sym_db = _symbol_database.Default()\n\n\nfrom google.protobuf import timestamp_pb2 as google_dot_protobuf_dot_timestamp__pb2\nfrom google.protobuf import any_pb2 as google_dot_protobuf_dot_any__pb2\nfrom google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2\n\n\nDESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\\n\\ngbft.proto\\x1a\\x1fgoogle/protobuf/timestamp.proto\\x1a\\x19google/protobuf/any.proto\\x1a\\x1bgoogle/protobuf/empty.proto\\\"\\xdd\\x02\\n\\x0bRequestData\\x12\\x0e\\n\\x06\\x63lient\\x18\\x01 \\x01(\\x05\\x12\\x13\\n\\x0brequest_num\\x18\\x02 \\x01(\\x03\\x12\\x0e\\n\\x06record\\x18\\x03 \\x01(\\x05\\x12)\\n\\toperation\\x18\\x04 \\x01(\\x0e\\x32\\x16.RequestData.Operation\\x12\\r\\n\\x05value\\x18\\x05 \\x01(\\x05\\x12-\\n\\ttimestamp\\x18\\x06 \\x01(\\x0b\\x32\\x1a.google.protobuf.Timestamp\\x12$\\n\\rreport_quorum\\x18\\x07 \\x03(\\x0b\\x32\\r.LearningData\\x12\\x15\\n\\rrequest_dummy\\x18\\x08 \\x01(\\x0c\\x12\\x16\\n\\x0e\\x63ompute_factor\\x18\\t \\x01(\\x05\\x12\\x12\\n\\nreply_size\\x18\\n \\x01(\\x05\\\"G\\n\\tOperation\\x12\\x07\\n\\x03NOP\\x10\\x00\\x12\\x07\\n\\x03\\x41\\x44\\x44\\x10\\x01\\x12\\x07\\n\\x03SUB\\x10\\x02\\x12\\x07\\n\\x03INC\\x10\\x03\\x12\\x07\\n\\x03\\x44\\x45\\x43\\x10\\x04\\x12\\r\\n\\tREAD_ONLY\\x10\\x05\\\"\\xca\\x05\\n\\x0bMessageData\\x12\\x14\\n\\x0csequence_num\\x18\\x01 \\x01(\\x03\\x12\\x10\\n\\x08view_num\\x18\\x02 \\x01(\\x03\\x12\\x14\\n\\x0cmessage_type\\x18\\x03 \\x01(\\x05\\x12\\x0e\\n\\x06source\\x18\\x04 \\x01(\\x05\\x12\\x0f\\n\\x07targets\\x18\\x05 \\x03(\\x05\\x12\\x1e\\n\\x08requests\\x18\\x06 \\x03(\\x0b\\x32\\x0c.RequestData\\x12\\x14\\n\\x0crequest_nums\\x18\\x07 \\x03(\\x03\\x12\\x18\\n\\x10has_request_data\\x18\\x08 \\x01(\\x08\\x12\\x0e\\n\\x06\\x64igest\\x18\\t \\x01(\\x0c\\x12\\r\\n\\x05\\x66lags\\x18\\n \\x03(\\x05\\x12/\\n\\nreply_data\\x18\\x0b \\x03(\\x0b\\x32\\x1b.MessageData.ReplyDataEntry\\x12\\x33\\n\\x0c\\x65xtra_values\\x18\\x0c \\x03(\\x0b\\x32\\x1d.MessageData.ExtraValuesEntry\\x12/\\n\\nextra_data\\x18\\r \\x03(\\x0b\\x32\\x1b.MessageData.ExtraDataEntry\\x12-\\n\\ttimestamp\\x18\\x0e \\x01(\\x0b\\x32\\x1a.google.protobuf.Timestamp\\x12\\x19\\n\\x05\\x66\\x61ult\\x18\\x0f \\x01(\\x0b\\x32\\n.FaultData\\x12\\x19\\n\\x05\\x66\\x65tch\\x18\\x10 \\x01(\\x0b\\x32\\n.FetchData\\x12\\x1d\\n\\x06report\\x18\\x11 \\x01(\\x0b\\x32\\r.LearningData\\x12\\x1e\\n\\x06switch\\x18\\x12 \\x01(\\x0b\\x32\\x0e.SwitchingData\\x12\\x1a\\n\\x12\\x61ggregation_values\\x18\\x13 \\x03(\\x03\\x1a\\x30\\n\\x0eReplyDataEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\x03\\x12\\r\\n\\x05value\\x18\\x02 \\x01(\\x05:\\x02\\x38\\x01\\x1a\\x32\\n\\x10\\x45xtraValuesEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\x05\\x12\\r\\n\\x05value\\x18\\x02 \\x01(\\x03:\\x02\\x38\\x01\\x1a\\x30\\n\\x0e\\x45xtraDataEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\x05\\x12\\r\\n\\x05value\\x18\\x02 \\x01(\\x0c:\\x02\\x38\\x01\\\"<\\n\\rSwitchingData\\x12\\x14\\n\\x0cswitch_ready\\x18\\x01 \\x01(\\x08\\x12\\x15\\n\\rnext_protocol\\x18\\x02 \\x01(\\t\\\"\\x7f\\n\\x0cLearningData\\x12)\\n\\x06report\\x18\\x01 \\x03(\\x0b\\x32\\x19.LearningData.ReportEntry\\x12\\x15\\n\\rnext_protocol\\x18\\x02 \\x01(\\t\\x1a-\\n\\x0bReportEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\x05\\x12\\r\\n\\x05value\\x18\\x02 \\x01(\\x02:\\x02\\x38\\x01\\\"\\x89\\x01\\n\\tFetchData\\x12\\x12\\n\\nis_request\\x18\\x01 \\x01(\\x08\\x12\\x33\\n\\rservice_state\\x18\\x02 \\x03(\\x0b\\x32\\x1c.FetchData.ServiceStateEntry\\x1a\\x33\\n\\x11ServiceStateEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\x05\\x12\\r\\n\\x05value\\x18\\x02 \\x01(\\x05:\\x02\\x38\\x01\\\"L\\n\\tFaultData\\x12\\x17\\n\\x0f\\x62locked_targets\\x18\\x01 \\x03(\\x05\\x12\\x17\\n\\x0f\\x64\\x65layed_targets\\x18\\x02 \\x03(\\x05\\x12\\r\\n\\x05\\x64\\x65lay\\x18\\x03 \\x01(\\x03\\\"2\\n\\x0cMessageBlock\\x12\\\"\\n\\x0cmessage_data\\x18\\x06 \\x03(\\x0b\\x32\\x0c.MessageData\\\"\\xb3\\x03\\n\\x05\\x45vent\\x12$\\n\\nevent_type\\x18\\x01 \\x01(\\x0e\\x32\\x10.Event.EventType\\x12\\x1e\\n\\tunit_data\\x18\\x02 \\x01(\\x0b\\x32\\t.UnitDataH\\x00\\x12\\\"\\n\\x0b\\x63onfig_data\\x18\\x03 \\x01(\\x0b\\x32\\x0b.ConfigDataH\\x00\\x12\\\"\\n\\x0bplugin_data\\x18\\x04 \\x01(\\x0b\\x32\\x0b.PluginDataH\\x00\\x12\\\"\\n\\x0breport_data\\x18\\x05 \\x01(\\x0b\\x32\\x0b.ReportDataH\\x00\\x12&\\n\\rmessage_block\\x18\\x06 \\x01(\\x0b\\x32\\r.MessageBlockH\\x00\\x12\\x10\\n\\x06target\\x18\\x07 \\x01(\\x05H\\x00\\\"\\xaf\\x01\\n\\tEventType\\x12\\x08\\n\\x04INIT\\x10\\x00\\x12\\n\\n\\x06\\x43ONFIG\\x10\\x01\\x12\\t\\n\\x05READY\\x10\\x02\\x12\\x0f\\n\\x0bPLUGIN_INIT\\x10\\x03\\x12\\t\\n\\x05START\\x10\\x04\\x12\\t\\n\\x05\\x42LOCK\\x10\\x05\\x12\\x08\\n\\x04STOP\\x10\\x06\\x12\\x08\\n\\x04\\x45XIT\\x10\\x07\\x12\\x13\\n\\x0f\\x42\\x45NCHMARK_START\\x10\\x08\\x12\\x14\\n\\x10\\x42\\x45NCHMARK_REPORT\\x10\\t\\x12\\x0b\\n\\x07MESSAGE\\x10\\n\\x12\\x0e\\n\\nCONNECTION\\x10\\x0b\\x42\\x0c\\n\\nevent_data\\\"B\\n\\x08UnitData\\x12\\x0c\\n\\x04unit\\x18\\x01 \\x01(\\x05\\x12\\x12\\n\\nnode_count\\x18\\x02 \\x01(\\x05\\x12\\x14\\n\\x0c\\x63lient_count\\x18\\x03 \\x01(\\x05\\\"\\x91\\x01\\n\\nConfigData\\x12#\\n\\x04\\x64\\x61ta\\x18\\x01 \\x03(\\x0b\\x32\\x15.ConfigData.DataEntry\\x12\\x17\\n\\x0f\\x64\\x65\\x66\\x61ultProtocol\\x18\\x02 \\x01(\\t\\x12\\x18\\n\\x05units\\x18\\x03 \\x03(\\x0b\\x32\\t.UnitData\\x1a+\\n\\tDataEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\t\\x12\\r\\n\\x05value\\x18\\x02 \\x01(\\t:\\x02\\x38\\x01\\\"f\\n\\nPluginData\\x12\\x13\\n\\x0bplugin_name\\x18\\x01 \\x01(\\t\\x12\\x14\\n\\x0cmessage_type\\x18\\x02 \\x01(\\x05\\x12\\x0c\\n\\x04\\x64\\x61ta\\x18\\x03 \\x01(\\x0c\\x12\\x0e\\n\\x06source\\x18\\x04 \\x01(\\x05\\x12\\x0f\\n\\x07targets\\x18\\x05 \\x03(\\x05\\\"\\x81\\x02\\n\\nReportData\\x12\\x30\\n\\x0breport_data\\x18\\x01 \\x03(\\x0b\\x32\\x1b.ReportData.ReportDataEntry\\x1aI\\n\\x0fReportDataEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\t\\x12%\\n\\x05value\\x18\\x02 \\x01(\\x0b\\x32\\x16.ReportData.ReportItem:\\x02\\x38\\x01\\x1av\\n\\nReportItem\\x12\\x37\\n\\titem_data\\x18\\x02 \\x03(\\x0b\\x32$.ReportData.ReportItem.ItemDataEntry\\x1a/\\n\\rItemDataEntry\\x12\\x0b\\n\\x03key\\x18\\x01 \\x01(\\t\\x12\\r\\n\\x05value\\x18\\x02 \\x01(\\t:\\x02\\x38\\x01\\x32\\x46\\n\\nEntityComm\\x12\\x38\\n\\rsend_decision\\x12\\r.LearningData\\x1a\\x16.google.protobuf.Empty\\\"\\x00\\x32\\x41\\n\\tAgentComm\\x12\\x34\\n\\tsend_data\\x12\\r.LearningData\\x1a\\x16.google.protobuf.Empty\\\"\\x00\\x42\\x1b\\n\\x17\\x63om.gbft.framework.dataP\\x01\\x62\\x06proto3')\n\n_globals = globals()\n_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)\n_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'gbft_pb2', _globals)\nif _descriptor._USE_C_DESCRIPTORS == False:\n  DESCRIPTOR._options = None\n  DESCRIPTOR._serialized_options = b'\\n\\027com.gbft.framework.dataP\\001'\n  _MESSAGEDATA_REPLYDATAENTRY._options = None\n  _MESSAGEDATA_REPLYDATAENTRY._serialized_options = b'8\\001'\n  _MESSAGEDATA_EXTRAVALUESENTRY._options = None\n  _MESSAGEDATA_EXTRAVALUESENTRY._serialized_options = b'8\\001'\n  _MESSAGEDATA_EXTRADATAENTRY._options = None\n  _MESSAGEDATA_EXTRADATAENTRY._serialized_options = b'8\\001'\n  _LEARNINGDATA_REPORTENTRY._options = None\n  _LEARNINGDATA_REPORTENTRY._serialized_options = b'8\\001'\n  _FETCHDATA_SERVICESTATEENTRY._options = None\n  _FETCHDATA_SERVICESTATEENTRY._serialized_options = b'8\\001'\n  _CONFIGDATA_DATAENTRY._options = None\n  _CONFIGDATA_DATAENTRY._serialized_options = b'8\\001'\n  _REPORTDATA_REPORTDATAENTRY._options = None\n  _REPORTDATA_REPORTDATAENTRY._serialized_options = b'8\\001'\n  _REPORTDATA_REPORTITEM_ITEMDATAENTRY._options = None\n  _REPORTDATA_REPORTITEM_ITEMDATAENTRY._serialized_options = b'8\\001'\n  _globals['_REQUESTDATA']._serialized_start=104\n  _globals['_REQUESTDATA']._serialized_end=453\n  _globals['_REQUESTDATA_OPERATION']._serialized_start=382\n  _globals['_REQUESTDATA_OPERATION']._serialized_end=453\n  _globals['_MESSAGEDATA']._serialized_start=456\n  _globals['_MESSAGEDATA']._serialized_end=1170\n  _globals['_MESSAGEDATA_REPLYDATAENTRY']._serialized_start=1020\n  _globals['_MESSAGEDATA_REPLYDATAENTRY']._serialized_end=1068\n  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._serialized_start=1070\n  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._serialized_end=1120\n  _globals['_MESSAGEDATA_EXTRADATAENTRY']._serialized_start=1122\n  _globals['_MESSAGEDATA_EXTRADATAENTRY']._serialized_end=1170\n  _globals['_SWITCHINGDATA']._serialized_start=1172\n  _globals['_SWITCHINGDATA']._serialized_end=1232\n  _globals['_LEARNINGDATA']._serialized_start=1234\n  _globals['_LEARNINGDATA']._serialized_end=1361\n  _globals['_LEARNINGDATA_REPORTENTRY']._serialized_start=1316\n  _globals['_LEARNINGDATA_REPORTENTRY']._serialized_end=1361\n  _globals['_FETCHDATA']._serialized_start=1364\n  _globals['_FETCHDATA']._serialized_end=1501\n  _globals['_FETCHDATA_SERVICESTATEENTRY']._serialized_start=1450\n  _globals['_FETCHDATA_SERVICESTATEENTRY']._serialized_end=1501\n  _globals['_FAULTDATA']._serialized_start=1503\n  _globals['_FAULTDATA']._serialized_end=1579\n  _globals['_MESSAGEBLOCK']._serialized_start=1581\n  _globals['_MESSAGEBLOCK']._serialized_end=1631\n  _globals['_EVENT']._serialized_start=1634\n  _globals['_EVENT']._serialized_end=2069\n  _globals['_EVENT_EVENTTYPE']._serialized_start=1880\n  _globals['_EVENT_EVENTTYPE']._serialized_end=2055\n  _globals['_UNITDATA']._serialized_start=2071\n  _globals['_UNITDATA']._serialized_end=2137\n  _globals['_CONFIGDATA']._serialized_start=2140\n  _globals['_CONFIGDATA']._serialized_end=2285\n  _globals['_CONFIGDATA_DATAENTRY']._serialized_start=2242\n  _globals['_CONFIGDATA_DATAENTRY']._serialized_end=2285\n  _globals['_PLUGINDATA']._serialized_start=2287\n  _globals['_PLUGINDATA']._serialized_end=2389\n  _globals['_REPORTDATA']._serialized_start=2392\n  _globals['_REPORTDATA']._serialized_end=2649\n  _globals['_REPORTDATA_REPORTDATAENTRY']._serialized_start=2456\n  _globals['_REPORTDATA_REPORTDATAENTRY']._serialized_end=2529\n  _globals['_REPORTDATA_REPORTITEM']._serialized_start=2531\n  _globals['_REPORTDATA_REPORTITEM']._serialized_end=2649\n  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._serialized_start=2602\n  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._serialized_end=2649\n  _globals['_ENTITYCOMM']._serialized_start=2651\n  _globals['_ENTITYCOMM']._serialized_end=2721\n  _globals['_AGENTCOMM']._serialized_start=2723\n  _globals['_AGENTCOMM']._serialized_end=2788\n# @@protoc_insertion_point(module_scope)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/learning/gbft_pb2.py b/code/learning/gbft_pb2.py
--- a/code/learning/gbft_pb2.py	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/learning/gbft_pb2.py	(date 1713840115817)
@@ -1,6 +1,7 @@
 # -*- coding: utf-8 -*-
 # Generated by the protocol buffer compiler.  DO NOT EDIT!
 # source: gbft.proto
+# Protobuf Python Version: 4.25.1
 """Generated protocol buffer code."""
 from google.protobuf import descriptor as _descriptor
 from google.protobuf import descriptor_pool as _descriptor_pool
@@ -16,78 +17,78 @@
 from google.protobuf import empty_pb2 as google_dot_protobuf_dot_empty__pb2
 
 
-DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\ngbft.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x19google/protobuf/any.proto\x1a\x1bgoogle/protobuf/empty.proto\"\xdd\x02\n\x0bRequestData\x12\x0e\n\x06\x63lient\x18\x01 \x01(\x05\x12\x13\n\x0brequest_num\x18\x02 \x01(\x03\x12\x0e\n\x06record\x18\x03 \x01(\x05\x12)\n\toperation\x18\x04 \x01(\x0e\x32\x16.RequestData.Operation\x12\r\n\x05value\x18\x05 \x01(\x05\x12-\n\ttimestamp\x18\x06 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12$\n\rreport_quorum\x18\x07 \x03(\x0b\x32\r.LearningData\x12\x15\n\rrequest_dummy\x18\x08 \x01(\x0c\x12\x16\n\x0e\x63ompute_factor\x18\t \x01(\x05\x12\x12\n\nreply_size\x18\n \x01(\x05\"G\n\tOperation\x12\x07\n\x03NOP\x10\x00\x12\x07\n\x03\x41\x44\x44\x10\x01\x12\x07\n\x03SUB\x10\x02\x12\x07\n\x03INC\x10\x03\x12\x07\n\x03\x44\x45\x43\x10\x04\x12\r\n\tREAD_ONLY\x10\x05\"\xca\x05\n\x0bMessageData\x12\x14\n\x0csequence_num\x18\x01 \x01(\x03\x12\x10\n\x08view_num\x18\x02 \x01(\x03\x12\x14\n\x0cmessage_type\x18\x03 \x01(\x05\x12\x0e\n\x06source\x18\x04 \x01(\x05\x12\x0f\n\x07targets\x18\x05 \x03(\x05\x12\x1e\n\x08requests\x18\x06 \x03(\x0b\x32\x0c.RequestData\x12\x14\n\x0crequest_nums\x18\x07 \x03(\x03\x12\x18\n\x10has_request_data\x18\x08 \x01(\x08\x12\x0e\n\x06\x64igest\x18\t \x01(\x0c\x12\r\n\x05\x66lags\x18\n \x03(\x05\x12/\n\nreply_data\x18\x0b \x03(\x0b\x32\x1b.MessageData.ReplyDataEntry\x12\x33\n\x0c\x65xtra_values\x18\x0c \x03(\x0b\x32\x1d.MessageData.ExtraValuesEntry\x12/\n\nextra_data\x18\r \x03(\x0b\x32\x1b.MessageData.ExtraDataEntry\x12-\n\ttimestamp\x18\x0e \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x19\n\x05\x66\x61ult\x18\x0f \x01(\x0b\x32\n.FaultData\x12\x19\n\x05\x66\x65tch\x18\x10 \x01(\x0b\x32\n.FetchData\x12\x1d\n\x06report\x18\x11 \x01(\x0b\x32\r.LearningData\x12\x1e\n\x06switch\x18\x12 \x01(\x0b\x32\x0e.SwitchingData\x12\x1a\n\x12\x61ggregation_values\x18\x13 \x03(\x03\x1a\x30\n\x0eReplyDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\x03\x12\r\n\x05value\x18\x02 \x01(\x05:\x02\x38\x01\x1a\x32\n\x10\x45xtraValuesEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x03:\x02\x38\x01\x1a\x30\n\x0e\x45xtraDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x0c:\x02\x38\x01\"<\n\rSwitchingData\x12\x14\n\x0cswitch_ready\x18\x01 \x01(\x08\x12\x15\n\rnext_protocol\x18\x02 \x01(\t\"\x7f\n\x0cLearningData\x12)\n\x06report\x18\x01 \x03(\x0b\x32\x19.LearningData.ReportEntry\x12\x15\n\rnext_protocol\x18\x02 \x01(\t\x1a-\n\x0bReportEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x02:\x02\x38\x01\"\x89\x01\n\tFetchData\x12\x12\n\nis_request\x18\x01 \x01(\x08\x12\x33\n\rservice_state\x18\x02 \x03(\x0b\x32\x1c.FetchData.ServiceStateEntry\x1a\x33\n\x11ServiceStateEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x05:\x02\x38\x01\"L\n\tFaultData\x12\x17\n\x0f\x62locked_targets\x18\x01 \x03(\x05\x12\x17\n\x0f\x64\x65layed_targets\x18\x02 \x03(\x05\x12\r\n\x05\x64\x65lay\x18\x03 \x01(\x03\"2\n\x0cMessageBlock\x12\"\n\x0cmessage_data\x18\x06 \x03(\x0b\x32\x0c.MessageData\"\xb3\x03\n\x05\x45vent\x12$\n\nevent_type\x18\x01 \x01(\x0e\x32\x10.Event.EventType\x12\x1e\n\tunit_data\x18\x02 \x01(\x0b\x32\t.UnitDataH\x00\x12\"\n\x0b\x63onfig_data\x18\x03 \x01(\x0b\x32\x0b.ConfigDataH\x00\x12\"\n\x0bplugin_data\x18\x04 \x01(\x0b\x32\x0b.PluginDataH\x00\x12\"\n\x0breport_data\x18\x05 \x01(\x0b\x32\x0b.ReportDataH\x00\x12&\n\rmessage_block\x18\x06 \x01(\x0b\x32\r.MessageBlockH\x00\x12\x10\n\x06target\x18\x07 \x01(\x05H\x00\"\xaf\x01\n\tEventType\x12\x08\n\x04INIT\x10\x00\x12\n\n\x06\x43ONFIG\x10\x01\x12\t\n\x05READY\x10\x02\x12\x0f\n\x0bPLUGIN_INIT\x10\x03\x12\t\n\x05START\x10\x04\x12\t\n\x05\x42LOCK\x10\x05\x12\x08\n\x04STOP\x10\x06\x12\x08\n\x04\x45XIT\x10\x07\x12\x13\n\x0f\x42\x45NCHMARK_START\x10\x08\x12\x14\n\x10\x42\x45NCHMARK_REPORT\x10\t\x12\x0b\n\x07MESSAGE\x10\n\x12\x0e\n\nCONNECTION\x10\x0b\x42\x0c\n\nevent_data\"B\n\x08UnitData\x12\x0c\n\x04unit\x18\x01 \x01(\x05\x12\x12\n\nnode_count\x18\x02 \x01(\x05\x12\x14\n\x0c\x63lient_count\x18\x03 \x01(\x05\"\x91\x01\n\nConfigData\x12#\n\x04\x64\x61ta\x18\x01 \x03(\x0b\x32\x15.ConfigData.DataEntry\x12\x17\n\x0f\x64\x65\x66\x61ultProtocol\x18\x02 \x01(\t\x12\x18\n\x05units\x18\x03 \x03(\x0b\x32\t.UnitData\x1a+\n\tDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\"f\n\nPluginData\x12\x13\n\x0bplugin_name\x18\x01 \x01(\t\x12\x14\n\x0cmessage_type\x18\x02 \x01(\x05\x12\x0c\n\x04\x64\x61ta\x18\x03 \x01(\x0c\x12\x0e\n\x06source\x18\x04 \x01(\x05\x12\x0f\n\x07targets\x18\x05 \x03(\x05\"\x81\x02\n\nReportData\x12\x30\n\x0breport_data\x18\x01 \x03(\x0b\x32\x1b.ReportData.ReportDataEntry\x1aI\n\x0fReportDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12%\n\x05value\x18\x02 \x01(\x0b\x32\x16.ReportData.ReportItem:\x02\x38\x01\x1av\n\nReportItem\x12\x37\n\titem_data\x18\x02 \x03(\x0b\x32$.ReportData.ReportItem.ItemDataEntry\x1a/\n\rItemDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x32\x46\n\nEntityComm\x12\x38\n\rsend_decision\x12\r.LearningData\x1a\x16.google.protobuf.Empty\"\x00\x32\x41\n\tAgentComm\x12\x34\n\tsend_data\x12\r.LearningData\x1a\x16.google.protobuf.Empty\"\x00\x42\x1b\n\x17\x63om.gbft.framework.dataP\x01\x62\x06proto3')
+DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\ngbft.proto\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x19google/protobuf/any.proto\x1a\x1bgoogle/protobuf/empty.proto\"\xf0\x02\n\x0bRequestData\x12\x0e\n\x06\x63lient\x18\x01 \x01(\x05\x12\x13\n\x0brequest_num\x18\x02 \x01(\x03\x12\x0e\n\x06record\x18\x03 \x01(\x05\x12)\n\toperation\x18\x04 \x01(\x0e\x32\x16.RequestData.Operation\x12\r\n\x05value\x18\x05 \x01(\x05\x12-\n\ttimestamp\x18\x06 \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12$\n\rreport_quorum\x18\x07 \x03(\x0b\x32\r.LearningData\x12\x15\n\rrequest_dummy\x18\x08 \x01(\x0c\x12\x16\n\x0e\x63ompute_factor\x18\t \x01(\x05\x12\x12\n\nreply_size\x18\n \x01(\x05\x12\x11\n\texe_value\x18\x0b \x01(\x05\"G\n\tOperation\x12\x07\n\x03NOP\x10\x00\x12\x07\n\x03\x41\x44\x44\x10\x01\x12\x07\n\x03SUB\x10\x02\x12\x07\n\x03INC\x10\x03\x12\x07\n\x03\x44\x45\x43\x10\x04\x12\r\n\tREAD_ONLY\x10\x05\"\xca\x05\n\x0bMessageData\x12\x14\n\x0csequence_num\x18\x01 \x01(\x03\x12\x10\n\x08view_num\x18\x02 \x01(\x03\x12\x14\n\x0cmessage_type\x18\x03 \x01(\x05\x12\x0e\n\x06source\x18\x04 \x01(\x05\x12\x0f\n\x07targets\x18\x05 \x03(\x05\x12\x1e\n\x08requests\x18\x06 \x03(\x0b\x32\x0c.RequestData\x12\x14\n\x0crequest_nums\x18\x07 \x03(\x03\x12\x18\n\x10has_request_data\x18\x08 \x01(\x08\x12\x0e\n\x06\x64igest\x18\t \x01(\x0c\x12\r\n\x05\x66lags\x18\n \x03(\x05\x12/\n\nreply_data\x18\x0b \x03(\x0b\x32\x1b.MessageData.ReplyDataEntry\x12\x33\n\x0c\x65xtra_values\x18\x0c \x03(\x0b\x32\x1d.MessageData.ExtraValuesEntry\x12/\n\nextra_data\x18\r \x03(\x0b\x32\x1b.MessageData.ExtraDataEntry\x12-\n\ttimestamp\x18\x0e \x01(\x0b\x32\x1a.google.protobuf.Timestamp\x12\x19\n\x05\x66\x61ult\x18\x0f \x01(\x0b\x32\n.FaultData\x12\x19\n\x05\x66\x65tch\x18\x10 \x01(\x0b\x32\n.FetchData\x12\x1d\n\x06report\x18\x11 \x01(\x0b\x32\r.LearningData\x12\x1e\n\x06switch\x18\x12 \x01(\x0b\x32\x0e.SwitchingData\x12\x1a\n\x12\x61ggregation_values\x18\x13 \x03(\x03\x1a\x30\n\x0eReplyDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\x03\x12\r\n\x05value\x18\x02 \x01(\x05:\x02\x38\x01\x1a\x32\n\x10\x45xtraValuesEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x03:\x02\x38\x01\x1a\x30\n\x0e\x45xtraDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x0c:\x02\x38\x01\"<\n\rSwitchingData\x12\x14\n\x0cswitch_ready\x18\x01 \x01(\x08\x12\x15\n\rnext_protocol\x18\x02 \x01(\t\"\x7f\n\x0cLearningData\x12)\n\x06report\x18\x01 \x03(\x0b\x32\x19.LearningData.ReportEntry\x12\x15\n\rnext_protocol\x18\x02 \x01(\t\x1a-\n\x0bReportEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x02:\x02\x38\x01\"\x89\x01\n\tFetchData\x12\x12\n\nis_request\x18\x01 \x01(\x08\x12\x33\n\rservice_state\x18\x02 \x03(\x0b\x32\x1c.FetchData.ServiceStateEntry\x1a\x33\n\x11ServiceStateEntry\x12\x0b\n\x03key\x18\x01 \x01(\x05\x12\r\n\x05value\x18\x02 \x01(\x05:\x02\x38\x01\"L\n\tFaultData\x12\x17\n\x0f\x62locked_targets\x18\x01 \x03(\x05\x12\x17\n\x0f\x64\x65layed_targets\x18\x02 \x03(\x05\x12\r\n\x05\x64\x65lay\x18\x03 \x01(\x03\"2\n\x0cMessageBlock\x12\"\n\x0cmessage_data\x18\x06 \x03(\x0b\x32\x0c.MessageData\"\xb3\x03\n\x05\x45vent\x12$\n\nevent_type\x18\x01 \x01(\x0e\x32\x10.Event.EventType\x12\x1e\n\tunit_data\x18\x02 \x01(\x0b\x32\t.UnitDataH\x00\x12\"\n\x0b\x63onfig_data\x18\x03 \x01(\x0b\x32\x0b.ConfigDataH\x00\x12\"\n\x0bplugin_data\x18\x04 \x01(\x0b\x32\x0b.PluginDataH\x00\x12\"\n\x0breport_data\x18\x05 \x01(\x0b\x32\x0b.ReportDataH\x00\x12&\n\rmessage_block\x18\x06 \x01(\x0b\x32\r.MessageBlockH\x00\x12\x10\n\x06target\x18\x07 \x01(\x05H\x00\"\xaf\x01\n\tEventType\x12\x08\n\x04INIT\x10\x00\x12\n\n\x06\x43ONFIG\x10\x01\x12\t\n\x05READY\x10\x02\x12\x0f\n\x0bPLUGIN_INIT\x10\x03\x12\t\n\x05START\x10\x04\x12\t\n\x05\x42LOCK\x10\x05\x12\x08\n\x04STOP\x10\x06\x12\x08\n\x04\x45XIT\x10\x07\x12\x13\n\x0f\x42\x45NCHMARK_START\x10\x08\x12\x14\n\x10\x42\x45NCHMARK_REPORT\x10\t\x12\x0b\n\x07MESSAGE\x10\n\x12\x0e\n\nCONNECTION\x10\x0b\x42\x0c\n\nevent_data\"B\n\x08UnitData\x12\x0c\n\x04unit\x18\x01 \x01(\x05\x12\x12\n\nnode_count\x18\x02 \x01(\x05\x12\x14\n\x0c\x63lient_count\x18\x03 \x01(\x05\"\x91\x01\n\nConfigData\x12#\n\x04\x64\x61ta\x18\x01 \x03(\x0b\x32\x15.ConfigData.DataEntry\x12\x17\n\x0f\x64\x65\x66\x61ultProtocol\x18\x02 \x01(\t\x12\x18\n\x05units\x18\x03 \x03(\x0b\x32\t.UnitData\x1a+\n\tDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\"f\n\nPluginData\x12\x13\n\x0bplugin_name\x18\x01 \x01(\t\x12\x14\n\x0cmessage_type\x18\x02 \x01(\x05\x12\x0c\n\x04\x64\x61ta\x18\x03 \x01(\x0c\x12\x0e\n\x06source\x18\x04 \x01(\x05\x12\x0f\n\x07targets\x18\x05 \x03(\x05\"\x81\x02\n\nReportData\x12\x30\n\x0breport_data\x18\x01 \x03(\x0b\x32\x1b.ReportData.ReportDataEntry\x1aI\n\x0fReportDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12%\n\x05value\x18\x02 \x01(\x0b\x32\x16.ReportData.ReportItem:\x02\x38\x01\x1av\n\nReportItem\x12\x37\n\titem_data\x18\x02 \x03(\x0b\x32$.ReportData.ReportItem.ItemDataEntry\x1a/\n\rItemDataEntry\x12\x0b\n\x03key\x18\x01 \x01(\t\x12\r\n\x05value\x18\x02 \x01(\t:\x02\x38\x01\x32\x46\n\nEntityComm\x12\x38\n\rsend_decision\x12\r.LearningData\x1a\x16.google.protobuf.Empty\"\x00\x32\x41\n\tAgentComm\x12\x34\n\tsend_data\x12\r.LearningData\x1a\x16.google.protobuf.Empty\"\x00\x42\x1b\n\x17\x63om.gbft.framework.dataP\x01\x62\x06proto3')
 
 _globals = globals()
 _builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
 _builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'gbft_pb2', _globals)
 if _descriptor._USE_C_DESCRIPTORS == False:
-  DESCRIPTOR._options = None
-  DESCRIPTOR._serialized_options = b'\n\027com.gbft.framework.dataP\001'
-  _MESSAGEDATA_REPLYDATAENTRY._options = None
-  _MESSAGEDATA_REPLYDATAENTRY._serialized_options = b'8\001'
-  _MESSAGEDATA_EXTRAVALUESENTRY._options = None
-  _MESSAGEDATA_EXTRAVALUESENTRY._serialized_options = b'8\001'
-  _MESSAGEDATA_EXTRADATAENTRY._options = None
-  _MESSAGEDATA_EXTRADATAENTRY._serialized_options = b'8\001'
-  _LEARNINGDATA_REPORTENTRY._options = None
-  _LEARNINGDATA_REPORTENTRY._serialized_options = b'8\001'
-  _FETCHDATA_SERVICESTATEENTRY._options = None
-  _FETCHDATA_SERVICESTATEENTRY._serialized_options = b'8\001'
-  _CONFIGDATA_DATAENTRY._options = None
-  _CONFIGDATA_DATAENTRY._serialized_options = b'8\001'
-  _REPORTDATA_REPORTDATAENTRY._options = None
-  _REPORTDATA_REPORTDATAENTRY._serialized_options = b'8\001'
-  _REPORTDATA_REPORTITEM_ITEMDATAENTRY._options = None
-  _REPORTDATA_REPORTITEM_ITEMDATAENTRY._serialized_options = b'8\001'
+  _globals['DESCRIPTOR']._options = None
+  _globals['DESCRIPTOR']._serialized_options = b'\n\027com.gbft.framework.dataP\001'
+  _globals['_MESSAGEDATA_REPLYDATAENTRY']._options = None
+  _globals['_MESSAGEDATA_REPLYDATAENTRY']._serialized_options = b'8\001'
+  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._options = None
+  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._serialized_options = b'8\001'
+  _globals['_MESSAGEDATA_EXTRADATAENTRY']._options = None
+  _globals['_MESSAGEDATA_EXTRADATAENTRY']._serialized_options = b'8\001'
+  _globals['_LEARNINGDATA_REPORTENTRY']._options = None
+  _globals['_LEARNINGDATA_REPORTENTRY']._serialized_options = b'8\001'
+  _globals['_FETCHDATA_SERVICESTATEENTRY']._options = None
+  _globals['_FETCHDATA_SERVICESTATEENTRY']._serialized_options = b'8\001'
+  _globals['_CONFIGDATA_DATAENTRY']._options = None
+  _globals['_CONFIGDATA_DATAENTRY']._serialized_options = b'8\001'
+  _globals['_REPORTDATA_REPORTDATAENTRY']._options = None
+  _globals['_REPORTDATA_REPORTDATAENTRY']._serialized_options = b'8\001'
+  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._options = None
+  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._serialized_options = b'8\001'
   _globals['_REQUESTDATA']._serialized_start=104
-  _globals['_REQUESTDATA']._serialized_end=453
-  _globals['_REQUESTDATA_OPERATION']._serialized_start=382
-  _globals['_REQUESTDATA_OPERATION']._serialized_end=453
-  _globals['_MESSAGEDATA']._serialized_start=456
-  _globals['_MESSAGEDATA']._serialized_end=1170
-  _globals['_MESSAGEDATA_REPLYDATAENTRY']._serialized_start=1020
-  _globals['_MESSAGEDATA_REPLYDATAENTRY']._serialized_end=1068
-  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._serialized_start=1070
-  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._serialized_end=1120
-  _globals['_MESSAGEDATA_EXTRADATAENTRY']._serialized_start=1122
-  _globals['_MESSAGEDATA_EXTRADATAENTRY']._serialized_end=1170
-  _globals['_SWITCHINGDATA']._serialized_start=1172
-  _globals['_SWITCHINGDATA']._serialized_end=1232
-  _globals['_LEARNINGDATA']._serialized_start=1234
-  _globals['_LEARNINGDATA']._serialized_end=1361
-  _globals['_LEARNINGDATA_REPORTENTRY']._serialized_start=1316
-  _globals['_LEARNINGDATA_REPORTENTRY']._serialized_end=1361
-  _globals['_FETCHDATA']._serialized_start=1364
-  _globals['_FETCHDATA']._serialized_end=1501
-  _globals['_FETCHDATA_SERVICESTATEENTRY']._serialized_start=1450
-  _globals['_FETCHDATA_SERVICESTATEENTRY']._serialized_end=1501
-  _globals['_FAULTDATA']._serialized_start=1503
-  _globals['_FAULTDATA']._serialized_end=1579
-  _globals['_MESSAGEBLOCK']._serialized_start=1581
-  _globals['_MESSAGEBLOCK']._serialized_end=1631
-  _globals['_EVENT']._serialized_start=1634
-  _globals['_EVENT']._serialized_end=2069
-  _globals['_EVENT_EVENTTYPE']._serialized_start=1880
-  _globals['_EVENT_EVENTTYPE']._serialized_end=2055
-  _globals['_UNITDATA']._serialized_start=2071
-  _globals['_UNITDATA']._serialized_end=2137
-  _globals['_CONFIGDATA']._serialized_start=2140
-  _globals['_CONFIGDATA']._serialized_end=2285
-  _globals['_CONFIGDATA_DATAENTRY']._serialized_start=2242
-  _globals['_CONFIGDATA_DATAENTRY']._serialized_end=2285
-  _globals['_PLUGINDATA']._serialized_start=2287
-  _globals['_PLUGINDATA']._serialized_end=2389
-  _globals['_REPORTDATA']._serialized_start=2392
-  _globals['_REPORTDATA']._serialized_end=2649
-  _globals['_REPORTDATA_REPORTDATAENTRY']._serialized_start=2456
-  _globals['_REPORTDATA_REPORTDATAENTRY']._serialized_end=2529
-  _globals['_REPORTDATA_REPORTITEM']._serialized_start=2531
-  _globals['_REPORTDATA_REPORTITEM']._serialized_end=2649
-  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._serialized_start=2602
-  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._serialized_end=2649
-  _globals['_ENTITYCOMM']._serialized_start=2651
-  _globals['_ENTITYCOMM']._serialized_end=2721
-  _globals['_AGENTCOMM']._serialized_start=2723
-  _globals['_AGENTCOMM']._serialized_end=2788
+  _globals['_REQUESTDATA']._serialized_end=472
+  _globals['_REQUESTDATA_OPERATION']._serialized_start=401
+  _globals['_REQUESTDATA_OPERATION']._serialized_end=472
+  _globals['_MESSAGEDATA']._serialized_start=475
+  _globals['_MESSAGEDATA']._serialized_end=1189
+  _globals['_MESSAGEDATA_REPLYDATAENTRY']._serialized_start=1039
+  _globals['_MESSAGEDATA_REPLYDATAENTRY']._serialized_end=1087
+  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._serialized_start=1089
+  _globals['_MESSAGEDATA_EXTRAVALUESENTRY']._serialized_end=1139
+  _globals['_MESSAGEDATA_EXTRADATAENTRY']._serialized_start=1141
+  _globals['_MESSAGEDATA_EXTRADATAENTRY']._serialized_end=1189
+  _globals['_SWITCHINGDATA']._serialized_start=1191
+  _globals['_SWITCHINGDATA']._serialized_end=1251
+  _globals['_LEARNINGDATA']._serialized_start=1253
+  _globals['_LEARNINGDATA']._serialized_end=1380
+  _globals['_LEARNINGDATA_REPORTENTRY']._serialized_start=1335
+  _globals['_LEARNINGDATA_REPORTENTRY']._serialized_end=1380
+  _globals['_FETCHDATA']._serialized_start=1383
+  _globals['_FETCHDATA']._serialized_end=1520
+  _globals['_FETCHDATA_SERVICESTATEENTRY']._serialized_start=1469
+  _globals['_FETCHDATA_SERVICESTATEENTRY']._serialized_end=1520
+  _globals['_FAULTDATA']._serialized_start=1522
+  _globals['_FAULTDATA']._serialized_end=1598
+  _globals['_MESSAGEBLOCK']._serialized_start=1600
+  _globals['_MESSAGEBLOCK']._serialized_end=1650
+  _globals['_EVENT']._serialized_start=1653
+  _globals['_EVENT']._serialized_end=2088
+  _globals['_EVENT_EVENTTYPE']._serialized_start=1899
+  _globals['_EVENT_EVENTTYPE']._serialized_end=2074
+  _globals['_UNITDATA']._serialized_start=2090
+  _globals['_UNITDATA']._serialized_end=2156
+  _globals['_CONFIGDATA']._serialized_start=2159
+  _globals['_CONFIGDATA']._serialized_end=2304
+  _globals['_CONFIGDATA_DATAENTRY']._serialized_start=2261
+  _globals['_CONFIGDATA_DATAENTRY']._serialized_end=2304
+  _globals['_PLUGINDATA']._serialized_start=2306
+  _globals['_PLUGINDATA']._serialized_end=2408
+  _globals['_REPORTDATA']._serialized_start=2411
+  _globals['_REPORTDATA']._serialized_end=2668
+  _globals['_REPORTDATA_REPORTDATAENTRY']._serialized_start=2475
+  _globals['_REPORTDATA_REPORTDATAENTRY']._serialized_end=2548
+  _globals['_REPORTDATA_REPORTITEM']._serialized_start=2550
+  _globals['_REPORTDATA_REPORTITEM']._serialized_end=2668
+  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._serialized_start=2621
+  _globals['_REPORTDATA_REPORTITEM_ITEMDATAENTRY']._serialized_end=2668
+  _globals['_ENTITYCOMM']._serialized_start=2670
+  _globals['_ENTITYCOMM']._serialized_end=2740
+  _globals['_AGENTCOMM']._serialized_start=2742
+  _globals['_AGENTCOMM']._serialized_end=2807
 # @@protoc_insertion_point(module_scope)
Index: code/src/com/gbft/framework/utils/DataUtils.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.utils;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\nimport java.util.stream.IntStream;\n\nimport com.gbft.framework.data.ConfigData;\nimport com.gbft.framework.data.Event;\nimport com.gbft.framework.data.Event.EventType;\nimport com.gbft.framework.data.MessageBlock;\nimport com.gbft.framework.data.MessageData;\nimport com.gbft.framework.data.PluginData;\nimport com.gbft.framework.data.ReportData;\nimport com.gbft.framework.data.RequestData;\nimport com.gbft.framework.data.RequestData.Operation;\nimport com.gbft.framework.data.UnitData;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.Timestamp;\nimport com.google.protobuf.util.Timestamps;\n\npublic class DataUtils {\n\n    // Message Flag\n    public static final int INVALID = 1;\n\n    private static Random random = new Random();\n\n    public static MessageData invalidate(MessageData message) {\n        return MessageData.newBuilder(message).addFlags(INVALID).build();\n    }\n\n    public static UnitData createUnitData(int unit, int nodeCount, int clientCount) {\n        return UnitData.newBuilder().setUnit(unit).setNodeCount(nodeCount).setClientCount(clientCount).build();\n    }\n\n    public static ConfigData createConfigData(Map<String, String> configContent, String defaultProtocol, List<UnitData> unitDataList) {\n        return ConfigData.newBuilder().putAllData(configContent).setDefaultProtocol(defaultProtocol).addAllUnits(unitDataList).build();\n    }\n\n    public static PluginData createPluginData(String name, int messageType, ByteString data, int source,\n            List<Integer> targets) {\n        var builder = PluginData.newBuilder();\n        builder.setPluginName(name)\n               .setMessageType(messageType)\n               .setData(data)\n               .setSource(source)\n               .addAllTargets(targets);\n\n        return builder.build();\n    }\n\n    public static Event createEvent(EventType eventType) {\n        return Event.newBuilder().setEventType(eventType).build();\n    }\n\n    public static Event createEvent(EventType eventType, int target) {\n        return Event.newBuilder().setEventType(eventType).setTarget(target).build();\n    }\n\n    public static Event createEvent(UnitData unitData) {\n        return Event.newBuilder().setEventType(EventType.INIT).setUnitData(unitData).build();\n    }\n\n    public static Event createEvent(ConfigData configData) {\n        return Event.newBuilder().setEventType(EventType.CONFIG).setConfigData(configData).build();\n    }\n\n    public static Event createEvent(PluginData pluginData) {\n        return Event.newBuilder().setEventType(EventType.PLUGIN_INIT).setPluginData(pluginData).build();\n    }\n\n    public static Event createEvent(ReportData reportData) {\n        return Event.newBuilder().setEventType(EventType.BENCHMARK_REPORT).setReportData(reportData).build();\n    }\n\n    public static Event createEvent(List<MessageData> messages) {\n        var messageBlock = MessageBlock.newBuilder().addAllMessageData(messages).build();\n        return Event.newBuilder().setEventType(EventType.MESSAGE).setMessageBlock(messageBlock).build();\n    }\n\n    public static MessageData createMessage(Long seqnum, long viewNum, int messageType, int source,\n            List<Integer> targets, List<Long> reqnums, List<RequestData> requests, Map<Long, Integer> replies,\n            ByteString digest) {\n\n        var builder = MessageData.newBuilder();\n        builder.setViewNum(viewNum)\n               .setMessageType(messageType)\n               .setSource(source)\n               .addAllTargets(targets);\n\n        if (seqnum != null) {\n            builder.setSequenceNum(seqnum);\n        }\n\n        if (reqnums != null) {\n            builder.addAllRequestNums(reqnums);\n        }\n\n        if (requests != null) {\n            builder.addAllRequests(requests);\n        }\n\n        if (replies != null) {\n            builder.putAllReplyData(replies);\n        }\n\n        if (digest != null) {\n            builder.setDigest(digest);\n        }\n\n        builder.setTimestamp(Timestamps.fromNanos(System.nanoTime()));\n\n        return builder.build();\n    }\n\n    private static final int WORKLOAD_00 = 0;\n    private static final int WORKLOAD_04 = 1;\n    private static final int WORKLOAD_40 = 2;\n    private static final int WORKLOAD_44 = 3;\n\n    public static RequestData createRequest(long reqnum, int record, Operation operation, int value, int clientId) {\n        var probabilities = Config.doubleList(\"workload.distribution\");\n\n        var r = random.nextDouble();\n        var i = 0;\n        for (; i < probabilities.size(); i ++) {\n            r -= probabilities.get(i);\n            if (r <= 0) break;\n        }\n\n        int replySize = 0, requestSize = 0;\n\n        switch (i) {\n            case WORKLOAD_00:\n                requestSize = 0;\n                replySize = 0;\n                break;\n            case WORKLOAD_04:\n                requestSize = 0;\n                replySize = AdvanceConfig.integer(\"workload.payload.reply-size\");\n                break;\n            case WORKLOAD_40:\n                requestSize = AdvanceConfig.integer(\"workload.payload.request-size\");\n                replySize = 0;\n                break;\n            case WORKLOAD_44:\n                requestSize = AdvanceConfig.integer(\"workload.payload.request-size\");\n                replySize = AdvanceConfig.integer(\"workload.payload.reply-size\");\n                break;\n            default:\n                System.err.println(\"wrong workload number\");\n                break;\n        }\n\n        var builder = RequestData.newBuilder();\n\n        try {\n            builder.setRequestNum(reqnum)\n                   .setClient(clientId)\n                   .setRecord(record)\n                   .setOperation(operation)\n                   .setValue(value)\n                   .setReplySize(replySize)\n                   .setRequestDummy(ByteString.readFrom(new RandomDataStream(requestSize)))\n                   .setComputeFactor(AdvanceConfig.integer(\"workload.compute-factor\"))\n                   .setTimestamp(Timestamps.fromNanos(System.nanoTime()));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return builder.build();\n    }\n\n    public static ByteString getDigest(List<RequestData> requestBlock) {\n        var stream = new ByteArrayOutputStream();\n        try {\n            for (var request : requestBlock) {\n                stream.write(request.toBuilder()\n                                .clearRequestDummy()        // clear dummy part\n                                .build().toByteArray());\n            }\n            stream.flush();\n            stream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        return DataUtils.getDigest(stream.toByteArray());\n    }\n\n    public static ByteString getDigest(byte[] data) {\n        try {\n            var bytes = MessageDigest.getInstance(\"SHA-256\").digest(data);\n            return ByteString.copyFrom(bytes);\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static <R, A, B> R nestedGet(Map<A, Map<B, R>> map, A index1, B index2) {\n        var submap = map.get(index1);\n        return submap == null ? null : submap.get(index2);\n    }\n\n    public static <V> ConcurrentHashMap<Integer, V> concurrentMapWithDefaults(int count,\n            Function<Integer, V> defaultGenerator) {\n        var map = new ConcurrentHashMap<Integer, V>();\n        IntStream.range(0, count).forEach(num -> map.put(num, defaultGenerator.apply(num)));\n        return map;\n    }\n\n    public static long toLong(Timestamp timestamp) {\n        return timestamp.getSeconds() * 1000000000L + timestamp.getNanos();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/utils/DataUtils.java b/code/src/com/gbft/framework/utils/DataUtils.java
--- a/code/src/com/gbft/framework/utils/DataUtils.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/utils/DataUtils.java	(date 1713833855620)
@@ -171,6 +171,7 @@
                    .setRequestDummy(ByteString.readFrom(new RandomDataStream(requestSize)))
                    .setComputeFactor(AdvanceConfig.integer("workload.compute-factor"))
                    .setTimestamp(Timestamps.fromNanos(System.nanoTime()));
+
         } catch (IOException e) {
             e.printStackTrace();
         }
Index: data/proto/gbft.proto
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>syntax = \"proto3\";\n\noption java_package = \"com.gbft.framework.data\";\noption java_multiple_files = true;\n\nimport \"google/protobuf/timestamp.proto\";\nimport \"google/protobuf/any.proto\";\nimport \"google/protobuf/empty.proto\";\n\nservice EntityComm {\n    rpc send_decision (LearningData) returns (google.protobuf.Empty) {}\n}\n\nservice AgentComm {\n    rpc send_data (LearningData) returns (google.protobuf.Empty) {}\n}\n\nmessage RequestData {\n    enum Operation {\n        NOP = 0;\n        ADD = 1;\n        SUB = 2;\n        INC = 3;\n        DEC = 4;\n\t\tREAD_ONLY = 5;\n    }\n    \n    int32 client = 1;\n    int64 request_num = 2;\n    \n    int32 record = 3;\n    Operation operation = 4;\n    int32 value = 5;\n\n    google.protobuf.Timestamp timestamp = 6;\n    repeated LearningData report_quorum = 7;\n\n    bytes request_dummy = 8;\n    int32 compute_factor = 9;\n    int32 reply_size = 10;\n}\n\nmessage MessageData {\n    int64 sequence_num = 1;\n    int64 view_num = 2;\n    int32 message_type = 3;\n\n    int32 source = 4;\n    repeated int32 targets = 5;\n\n    repeated RequestData requests = 6;\n    repeated int64 request_nums = 7;\n    bool has_request_data = 8;\n    bytes digest = 9;\n\n\trepeated int32 flags = 10;\n    map<int64, int32> reply_data = 11;\n    map<int32, int64> extra_values = 12;\n    map<int32, bytes> extra_data = 13;\n\n    google.protobuf.Timestamp timestamp = 14;\n    FaultData fault = 15;\n    FetchData fetch = 16;\n    LearningData report = 17;\n    SwitchingData switch = 18;\n\n    repeated int64 aggregation_values = 19;\n}\n\nmessage SwitchingData {\n    bool switch_ready = 1;\n    string next_protocol = 2;\n}\n\nmessage LearningData {\n    map<int32, float> report = 1;\n    string next_protocol = 2;\n}\n\nmessage FetchData {\n    bool is_request = 1;\n    map<int32, int32> service_state = 2;\n}\n\nmessage FaultData {\n    repeated int32 blocked_targets = 1;\n    repeated int32 delayed_targets = 2;\n    int64 delay = 3;\n}\n\nmessage MessageBlock {\n    repeated MessageData message_data = 6;\n}\n\nmessage Event {\n    enum EventType {\n        INIT = 0;\n        CONFIG = 1;\n        READY = 2;\n        PLUGIN_INIT = 3;\n        START = 4;\n        BLOCK = 5;\n        STOP = 6;\n        EXIT = 7;\n        BENCHMARK_START = 8;\n        BENCHMARK_REPORT = 9;\n        MESSAGE = 10;\n        CONNECTION = 11;\n    }\n\n    EventType event_type = 1;\n\n    oneof event_data {\n        UnitData unit_data = 2;\n        ConfigData config_data = 3;\n        PluginData plugin_data = 4;\n        ReportData report_data = 5;\n        MessageBlock message_block = 6;\n        int32 target = 7;\n    }\n}\n\nmessage UnitData {\n    int32 unit = 1;\n    int32 node_count = 2;\n    int32 client_count = 3;\n}\n\nmessage ConfigData {\n    map<string, string> data = 1;\n    string defaultProtocol = 2;\n    repeated UnitData units = 3;\n}\n\nmessage PluginData {\n    string plugin_name = 1;\n    int32 message_type = 2;\n    bytes data = 3;\n    \n    int32 source = 4;\n    repeated int32 targets = 5;\n}\n\nmessage ReportData {\n    map<string, ReportItem> report_data = 1;\n\n    message ReportItem {\n        map<string, string> item_data = 2;\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/data/proto/gbft.proto b/data/proto/gbft.proto
--- a/data/proto/gbft.proto	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/data/proto/gbft.proto	(date 1713843667021)
@@ -38,6 +38,7 @@
     bytes request_dummy = 8;
     int32 compute_factor = 9;
     int32 reply_size = 10;
+    int32 exeValue = 11;
 }
 
 message MessageData {
Index: code/src/com/gbft/framework/utils/CheckpointData.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.gbft.framework.utils;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NavigableSet;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.concurrent.atomic.LongAdder;\nimport java.util.concurrent.ConcurrentSkipListSet;\n\nimport com.gbft.framework.core.Dataset;\nimport com.gbft.framework.core.Entity;\nimport com.gbft.framework.data.MessageData;\nimport com.gbft.framework.data.RequestData;\nimport com.gbft.framework.statemachine.StateMachine;\nimport com.gbft.framework.utils.Printer;\nimport com.gbft.framework.utils.Printer.Verbosity;\n\npublic class CheckpointData {\n    private long num;\n    private Entity entity;\n\n    // seqnum -> state (state machine)\n    private Map<Long, Integer> stateMap;\n    private Map<Long, RequestData> requests;\n    private Map<Long, List<RequestData>> requestBlocks;\n    private Map<Long, NavigableSet<Long>> aggregationValues;\n    private MessageTally messageTally;\n    private MessageTally viewTally;\n    \n    // service state\n    protected Dataset serviceState;\n\n    // counter for next(i)\n    protected Map<String, LongAdder> decisionMatching;\n    private static int decisionQuorumSize = 1;\n\n    // protocol\n    protected AtomicReference<String> protocol = new AtomicReference<>();\n\n    // performance\n    public long beginTimestamp;\n    public float throughput;\n\n    protected Map<Long, Map<Long, Integer>> replies;\n\n    public CheckpointData(long num, Entity entity) {\n        this.num = num;\n        this.entity = entity;\n        stateMap = new ConcurrentHashMap<>();\n        requests = new ConcurrentHashMap<>();\n        requestBlocks = new ConcurrentHashMap<>();\n        aggregationValues = new ConcurrentHashMap<>();\n        messageTally = new MessageTally();\n        viewTally = new MessageTally();\n        serviceState = null;\n        replies = new HashMap<>();\n        decisionMatching = new ConcurrentHashMap<>();\n    }\n\n    /**\n     * Clone dataset, invoked in Node.java (Node, not Client)\n     * Only invoke when (seqnum+1) % checkpointSize == 0\n     * @param currentServiceState current dataset\n     */\n    public void setServiceState(Dataset currentServiceState) {\n        this.serviceState = new Dataset(currentServiceState);\n    }\n\n    public Dataset getServiceState() {\n        return serviceState;\n    }\n\n    public void tally(MessageData message) {\n        messageTally.tally(message);\n        viewTally.tally(message.toBuilder().clearDigest().build());\n\n        // track number of received messages per slot\n        var seqnum = message.getSequenceNum();\n        if (seqnum == entity.getBeginOfEpisode(seqnum)) {\n            entity.getFeatureManager().count(entity.getEpisodeNum(seqnum), FeatureManager.RECEIVED_MESSAGE_PER_SLOT);\n        }\n\n        // timestamp when receiving leader proposal\n        var type = message.getMessageType();\n        if (StateMachine.messages.get(type).hasRequestBlock && type != StateMachine.REQUEST && type != StateMachine.REPLY) {\n            entity.getFeatureManager().received(entity.getEpisodeNum(seqnum), seqnum);\n        }\n\n        if (type == StateMachine.REPLY && !message.getSwitch().getNextProtocol().isEmpty()) {\n            decisionMatching.computeIfAbsent(message.getSwitch().getNextProtocol(), p -> new LongAdder()).increment();\n        }\n\n        // used to debug tally stack trace\n        if (Printer.verbosity >= Verbosity.VVVVVV) {\n            StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();\n\n            var sb = new StringBuilder(\"\");\n            for (var element : stackTraceElements) {\n                sb.append(\" class: \" + element.getClassName() + \" file: \" + element.getFileName() + \" line: \" + element.getLineNumber() + \" method: \" + element.getMethodName() + \"\\n\");\n            }\n\n            Printer.print(Verbosity.VVVVVV, \"Tally stacktrace \", sb.toString().trim());\n        }\n    }\n\n    public void tallyDecision(String decision) {\n        decisionMatching.computeIfAbsent(decision, p -> new LongAdder()).increment();\n    }\n\n    public void addAggregationValue(MessageData message) {\n        var seqnum = message.getSequenceNum();\n        if (!message.getAggregationValuesList().isEmpty()) {\n            aggregationValues.computeIfAbsent(seqnum, k -> new ConcurrentSkipListSet<>()).addAll(message.getAggregationValuesList());\n        }\n    }\n\n    public void addAggregationValue(long seqnum, Set<Long> values) {\n        if (!values.isEmpty()) {\n            aggregationValues.computeIfAbsent(seqnum, k -> new ConcurrentSkipListSet<>()).addAll(values);\n        }\n    }\n\n    public NavigableSet<Long> getAggregationValues(long seqnum) {\n        return aggregationValues.getOrDefault(seqnum, new ConcurrentSkipListSet<>());\n    }\n\n    public String getDecision() {\n        Optional<String> nextProtocol;\n        do {\n            nextProtocol = decisionMatching.entrySet().parallelStream()\n                    .filter(entry -> (entry.getValue().longValue() >= decisionQuorumSize)).map(entry -> entry.getKey())\n                    .findAny();\n        } while (!nextProtocol.isPresent());\n\n        return nextProtocol.get();\n    }\n\n    public void addRequestBlock(long seqnum, List<RequestData> requestBlock) {\n        requestBlock.forEach(request -> requests.put(request.getRequestNum(), request));\n        requestBlocks.put(seqnum, requestBlock);\n        // stateMap.put(seqnum, StateMachine.IDLE);\n    }\n\n    public RequestData getRequest(long reqnum) {\n        return requests.get(reqnum);\n    }\n\n    public List<RequestData> getRequestBlock(long seqnum) {\n        return requestBlocks.get(seqnum);\n    }\n\n    public void addReplies(long seqnum, Map<Long, Integer> blockReplies) {\n        replies.put(seqnum, blockReplies);\n    }\n\n    public Map<Long, Integer> getReplies(long seqnum) {\n        return replies.get(seqnum);\n    }\n\n    public MessageTally getMessageTally() {\n        return messageTally;\n    }\n\n    public MessageTally getViewTally() {\n        return viewTally;\n    }\n\n    /**\n     * Set state of a seqnum to state\n     * \n     * Set at `transition` and `execute` in `Entity.java`\n     * Updated in `StateUpdateLoop` in `Entity.java`\n     * @param seqnum sequence number\n     * @param state state\n     */\n    public void setState(long seqnum, int state) {\n        stateMap.put(seqnum, state);\n    }\n\n    /**\n     * Get state of a seqnum\n     * @param seqnum sequence number\n     * @return state\n     */\n    public int getState(long seqnum) {\n        if (protocol.get() == null) {\n            return StateMachine.ANY_STATE;\n        } else {\n            return stateMap.getOrDefault(seqnum, StateMachine.states.indexOf(StateMachine.findState(\"idle\", protocol.get() + \"_\")));\n        }\n    }\n\n    public long getNum() {\n        return num;\n    }\n\n    public void setProtocol(String protocol) {\n        this.protocol.set(protocol);\n    }\n\n    public String getProtocol() {\n        return protocol.get();\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/code/src/com/gbft/framework/utils/CheckpointData.java b/code/src/com/gbft/framework/utils/CheckpointData.java
--- a/code/src/com/gbft/framework/utils/CheckpointData.java	(revision 851e5dae18ebd70650d77e63726c2bad0c4a4ff6)
+++ b/code/src/com/gbft/framework/utils/CheckpointData.java	(date 1713907316629)
@@ -130,6 +130,7 @@
 
     public String getDecision() {
         Optional<String> nextProtocol;
+        entity.l.write(11,"decision: "+decisionMatching);
         do {
             nextProtocol = decisionMatching.entrySet().parallelStream()
                     .filter(entry -> (entry.getValue().longValue() >= decisionQuorumSize)).map(entry -> entry.getKey())
@@ -141,6 +142,10 @@
 
     public void addRequestBlock(long seqnum, List<RequestData> requestBlock) {
         requestBlock.forEach(request -> requests.put(request.getRequestNum(), request));
+        var requests=requestBlock;
+        for(var request:requests){
+            entity.l.write(entity.getId(), "\n{\nsingle_request_2:"+request.toString()+"\nvalue_2: "+request.getExeValue()+"}");
+        }
         requestBlocks.put(seqnum, requestBlock);
         // stateMap.put(seqnum, StateMachine.IDLE);
     }
